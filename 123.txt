cat << 'EOF' > test_chromedriver.py
from selenium import webdriver
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.chrome.options import Options

options = Options()
options.add_argument("--headless")
options.add_argument("--no-sandbox")
options.add_argument("--disable-dev-shm-usage")

service = Service("/usr/bin/chromedriver")
driver = webdriver.Chrome(service=service, options=options)

driver.get("https://www.google.com")
print("Title:", driver.title)

driver.quit()
EOF



ðŸ“¦ Python 3.9 packages (focal-updates)
https://archive.ubuntu.com/ubuntu/pool/universe/p/python3.9/python3.9_3.9.5-3ubuntu0~20.04.1_amd64.deb
https://archive.ubuntu.com/ubuntu/pool/universe/p/python3.9/python3.9-minimal_3.9.5-3ubuntu0~20.04.1_amd64.deb
https://archive.ubuntu.com/ubuntu/pool/universe/p/python3.9/python3.9-venv_3.9.5-3ubuntu0~20.04.1_amd64.deb
https://archive.ubuntu.com/ubuntu/pool/universe/p/python3.9/python3.9-dev_3.9.5-3ubuntu0~20.04.1_amd64.deb

ðŸ§° Support & library packages
https://archive.ubuntu.com/ubuntu/pool/universe/p/python3.9/libpython3.9_3.9.5-3ubuntu0~20.04.1_amd64.deb
https://archive.ubuntu.com/ubuntu/pool/universe/p/python3.9/libpython3.9-minimal_3.9.5-3ubuntu0~20.04.1_amd64.deb
https://archive.ubuntu.com/ubuntu/pool/universe/p/python3.9/libpython3.9-stdlib_3.9.5-3ubuntu0~20.04.1_amd64.deb
https://archive.ubuntu.com/ubuntu/pool/universe/p/python3.9/libpython3.9-dev_3.9.5-3ubuntu0~20.04.1_amd64.deb

ðŸ“Œ Optional extras
https://archive.ubuntu.com/ubuntu/pool/universe/p/python3.9/python3.9-dbg_3.9.5-3ubuntu0~20.04.1_amd64.deb
https://archive.ubuntu.com/ubuntu/pool/universe/p/python3.9/python3.9-examples_3.9.5-3ubuntu0~20.04.1_all.deb


âœ” These match the files listed in the official Ubuntu focal pool directory. 
Ubuntu Archive

How to download with wget

Example:

wget https://archive.ubuntu.com/ubuntu/pool/universe/p/python3.9/python3.9_3.9.5-3ubuntu0~20.04.1_amd64.deb


Then install them together:

sudo dpkg -i *.deb
sudo apt -f install


Make sure you include dependencies (libpython3.9*), or use apt install python3.9 instead. 
Ubuntu Archive

Tip: Easiest install (recommended)

Instead of manually downloading, you can install Python 3.9 using APT and enabled repositories:

sudo apt update
sudo apt install python3.9 python3.9-venv python3.9-dev


#############################################################################################
$RG = "rg-aci-demo"
$LOC = "uksouth"
$ACI_NAME = "aci-nexus-demo"
$DNS_LABEL = "aci-nexus"

$NEXUS_REGISTRY = "nexus.example.com:8083"
$IMAGE = "nexus.example.com:8083/myrepo/myimage:1.0"
$NEXUS_USER = "myuser"
$NEXUS_PASSWORD = "mypassword"

az group create `
  --name $RG `
  --location $LOC

az container create `
  --resource-group $RG `
  --name $ACI_NAME `
  --image $IMAGE `
  --registry-login-server $NEXUS_REGISTRY `
  --registry-username $NEXUS_USER `
  --registry-password $NEXUS_PASSWORD `
  --dns-name-label $DNS_LABEL `
  --ports 80 `
  --os-type Linux `
  --restart-policy Always


##########################################################################
# 1. Install prerequisites  
sudo apt-get update  
sudo apt-get install -y ca-certificates curl apt-transport-https gnupg lsb-release  

# 2. Add Microsoftâ€™s GPG key for package signing  
sudo mkdir -p /etc/apt/keyrings  
curl -sL https://packages.microsoft.com/keys/microsoft.asc \
  | gpg --dearmor \
  | sudo tee /etc/apt/keyrings/microsoft.gpg > /dev/null  
sudo chmod go+r /etc/apt/keyrings/microsoft.gpg

# 3. Add the Azure CLI repository  
AZ_DIST=$(lsb_release -cs)  # e.g. "focal", "jammy", etc.
echo "deb [arch=amd64 signed-by=/etc/apt/keyrings/microsoft.gpg] https://packages.microsoft.com/repos/azure-cli/ $AZ_DIST main" \
  | sudo tee /etc/apt/sources.list.d/azure-cli.list

# 4. Update and install Azure CLI  
sudo apt-get update  
sudo apt-get install -y azure-cli

# 5. Verify  
az version


######################################################################################
kubectl get pod -A -o wide --field-selector spec.nodeName=<NODE_NAME>

################
RG="<your-main-aks-rg>"
CLUSTER="<your-aks-cluster-name>"
SUBNET_ID="<existing-aks-subnet-resource-id>"   # same subnet as current pool

az aks nodepool add \
  --resource-group $RG \
  --cluster-name $CLUSTER \
  --name spotnodpool2 \
  --mode User \
  --priority Spot \
  --eviction-policy Delete \
  --spot-max-price -1 \                       # "On-demand pricing"
  --node-vm-size Standard_D8ads_v5 \
  --node-count 2 \                            # starting nodes
  --max-pods 60 \
  --enable-cluster-autoscaler \
  --min-count 2 \
  --max-count 5 \
  --vnet-subnet-id $SUBNET_ID \
  --zones 2 3 \
  --node-taints "kubernetes.azure.com/scalesetpriority=spot:NoSchedule" \
  --node-labels "kubernetes.azure.com/scalesetpriority=spot"

#######################################


docker commit \
  --change 'ENV AZP_URL=https://dev.azure.com/1111' \
  --change 'ENV AZP_TOKEN_SCALE=' \
  --change 'ENV AZP_TOKEN=' \
  --change 'ENV devops_svc_pass=' \
  tmp-container myimage-updated:latest

#####################################


az acr repository download \
  --name <ACR_NAME> \
  --image <repository>:<tag> \
  --path <output-folder>


##############################################################################



kubectl create secret generic kv-secret \
  --namespace=-linux-dev-blue \
  --from-literal=AZP_TOKEN=ffmdfsdfsdfsdfsd \
  --from-literal=devops_svc_pass=fsdfsdfsdfsdfsdfsd


#################################################################################

# Dockerfile
# Downloads Az .nupkg file directly from Nexus using curl
# Then installs it via PowerShell locally

FROM mcr.microsoft.com/powershell:7-ubuntu-22.04

ENV POWERSHELL_TELEMETRY_OPTOUT=1

# ---- build-time args ----
ARG AZ_VERSION=12.3.0
# Example:
#   https://nexus.example.com/repository/nuget_proxy_powershellgallery_iq/Az/12.3.0/Az.12.3.0.nupkg
ARG NEXUS_NUPKG_URL
# Optional: if Nexus requires auth, pass credentials here
ARG NEXUS_USER
ARG NEXUS_PASS

# Local path for the downloaded package
ENV NUPKG_PATH=/tmp/Az.nupkg

# Install curl & certificates
RUN apt-get update && apt-get install -y curl ca-certificates && rm -rf /var/lib/apt/lists/*

# ---- Download Az nupkg from Nexus ----
RUN set -eux; \
    if [ -z "$NEXUS_NUPKG_URL" ]; then \
        echo "âŒ ERROR: Must provide NEXUS_NUPKG_URL build arg"; exit 1; \
    fi; \
    echo "ðŸ“¦ Downloading Az module nupkg from Nexus..."; \
    if [ -n "$NEXUS_USER" ]; then \
        curl -u "${NEXUS_USER}:${NEXUS_PASS}" -L "$NEXUS_NUPKG_URL" -o "$NUPKG_PATH"; \
    else \
        curl -L "$NEXUS_NUPKG_URL" -o "$NUPKG_PATH"; \
    fi; \
    echo "âœ… Download complete: $NUPKG_PATH"

# ---- Install Az from the local .nupkg ----
RUN pwsh -NoLogo -NoProfile -Command \
    Set-StrictMode -Version Latest; \
    $pkg = $env:NUPKG_PATH; \
    if (-not (Test-Path $pkg)) { throw "Package not found: $pkg" }; \
    Install-PackageProvider -Name NuGet -Force -MinimumVersion 2.8.5.201 | Out-Null; \
    # Install the .nupkg directly from local path
    Install-Package -Name Az -Source $pkg -Force -Scope AllUsers; \
    # Verify installation
    Get-Module -ListAvailable Az | Out-Host

CMD ["pwsh"]


#################################################################################


DOCKER_BUILDKIT=1 docker build \
  --secret id=nexus-username,src=/path/to/nexus-username.txt \
  --secret id=nexus-password,src=/path/to/nexus-password.txt \
  -t my-image-name .



# 0) See what's masked/available
systemctl list-unit-files | grep -E '^(ssh|sshd)\.service'
systemctl status sshd || systemctl status ssh

# 1) Unmask (pick whichever exists)
sudo systemctl unmask sshd 2>/dev/null || sudo systemctl unmask ssh

# 2) Validate your SSH config before starting (very important)
sudo sshd -t || sudo /usr/sbin/sshd -t
# If this prints nothing, the config is OK.
# If it reports an error (your status showed a note about "sshd_config line 3"),
# fix /etc/ssh/sshd_config and re-run the test until it's clean.

# 3) Start and enable at boot
sudo systemctl enable --now sshd 2>/dev/null || sudo systemctl enable --now ssh

# 4) Verify it's running and listening
(systemctl is-active sshd || systemctl is-active ssh)
sudo ss -lntp | grep -E ':(22)\b|sshd' || sudo lsof -iTCP -sTCP:LISTEN -P | grep sshd

# 5) If it still wonâ€™t start, show logs
sudo journalctl -u sshd -b || sudo journalctl -u ssh -b

##########################################################

# Enable admin account (skip if already enabled)
az acr update -n <acrName> --admin-enabled true

# Fetch username & password
USER=$(az acr credential show -n <acrName> --query username -o tsv)
PASS=$(az acr credential show -n <acrName> --query "passwords[0].value" -o tsv)

# Docker login with the access key
echo "$PASS" | docker login <acrName>.azurecr.io -u "$USER" --password-stdin

# Tag & push
docker tag myimg:1.0 <acrName>.azurecr.io/myrepo/myimg:1.0
docker push <acrName>.azurecr.io/myrepo/myimg:1.0


###############################################################################################################
Hereâ€™s what that command adds/enables in your AKS cluster:

AKS add-on enabled: the Azure Container Storage add-on is turned on in the clusterâ€™s add-on profile.

System components installed: ACS operator/controllers and a node daemonset are deployed in the system namespace.

CRDs registered: ACS custom resources (e.g., StoragePool, Volume, replication objects) are added.

RBAC & webhooks: required ClusterRoles/RoleBindings and admission/webhook configs for ACS are created.

Not created yet: no StoragePools, StorageClasses, PVs, or backing disks are made until you define a StoragePool (thatâ€™s when StorageClasses and actual volumes appear). Existing pods/ PVCs are untouched.

You said:
give all the aks commands that will show all this changes
ChatGPT said:
Thought for 12s

Hereâ€™s a tight checklist of commands to verify everything ACS added after you enable it.

1) Add-on enabled (AKS control plane)
az aks show -g <rg> -n <cluster> --query "addonProfiles.azureContainerStorage.enabled" -o tsv
az aks show -g <rg> -n <cluster> --query "addonProfiles" -o json

2) System components (operators/daemonsets/pods)
# look for ACS controllers/agents
kubectl get deploy,ds,po -A | egrep -i "azure.*container.*storage|container.*storage|acs"
# (optional) details
kubectl get deploy,ds -n kube-system -o wide

3) CRDs installed
kubectl get crd | egrep -i "storagepool|container.*storage|azure.*container.*storage|volume"
kubectl api-resources | egrep -i "storagepool|volume|replica|replication"

4) RBAC + webhooks created
kubectl get clusterrole,clusterrolebinding | egrep -i "container.*storage|acs"
kubectl get validatingwebhookconfigurations,mutatingwebhookconfigurations | egrep -i "container.*storage|acs|volume"

5) StorageClasses (none until you make a StoragePool)
kubectl get storageclass

6) ACS custom resources (only after you create them)
# if/when you define a StoragePool, these should exist:
kubectl get storagepools --all-namespaces
kubectl get volumes --all-namespaces


Tip: if the name patterns differ in your build, keep the greps broad (as above) or run kubectl get all -A once and eyeball entries related to container/storage.
#################################################################################################################################################################


docker build `
  --build-arg NEXUS_URL="https://nexus.mycompany.com/repository" `
  --build-arg NEXUS_USER="my-nexus-username" `
  --build-arg NEXUS_PASS="my-nexus-token" `
  -t my-app:local .


######################


Step 1. Get your AKS clusterâ€™s kubelet identity
az aks show -g <resource-group> -n <cluster-name> \
  --query identityProfile.kubeletidentity.objectId -o tsv


Save that Object ID (something like b1234567-89ab-cdef-0123-456789abcdef).

Step 2. Grant ACR Pull permissions

Get the resource ID of your second registry:

az acr show -n <second-acr-name> --query id -o tsv


Then attach it:

az role assignment create \
  --assignee <kubelet_object_id> \
  --role AcrPull \
  --scope $(az acr show -n <second-acr-name> --query id -o tsv)


âœ… This explicitly gives your AKS nodes permission to pull from that registry.

ðŸ§© Step 3. Verify it worked

List all AcrPull role assignments for the kubelet identity:

az role assignment list \
  --assignee <kubelet_object_id> \
  --query "[?roleDefinitionName=='AcrPull'].[scope]" -o tsv

################################################################################


kubectl get pod <POD_NAME> -n <NAMESPACE> -o jsonpath='{.spec.containers[*].name}'



# Variables (replace with yours)
RESOURCE_GROUP="rg-linux-demo"
VM_NAME="rhelvm01"
LOCATION="westeurope"
SIZE="Standard_DS2_v2"
ADMIN_USER="azureuser"
SSH_KEY_PATH="$HOME/.ssh/id_rsa.pub"

# Existing resource IDs
IMAGE_ID="/subscriptions/<subId>/resourceGroups/<galleryRG>/providers/Microsoft.Compute/galleries/<galleryName>/images/<imageDefName>/versions/<version>"
SUBNET_ID="/subscriptions/<subId>/resourceGroups/<networkRG>/providers/Microsoft.Network/virtualNetworks/<vnetName>/subnets/<subnetName>"

# Create the VM
az vm create \
  --resource-group $RESOURCE_GROUP \
  --name $VM_NAME \
  --location $LOCATION \
  --size $SIZE \
  --admin-username $ADMIN_USER \
  --ssh-key-values $SSH_KEY_PATH \
  --image $IMAGE_ID \
  --subnet $SUBNET_ID 
########################################################################################
<# 
Azure DevOps Agent Pools Inventory
Auth: AAD client credentials EXACTLY as in the screenshot (oauth2/token + resource)
#>

param (
    [string]$AzOrgURL     = "",   # e.g. "https://dev.azure.com/contoso"
    [string]$tenantId     = "",
    [string]$clientId     = "",
    [string]$clientSecret = "",
    [string]$OutCsv       = ""    # e.g. "C:\temp\ado-agent-pools.csv"; leave blank to skip
)

# -------- AUTH (exactly like your picture) --------
$resource = "499b84ac-1321-427f-aa17-267ca6975798"

$body = @{
    grant_type    = "client_credentials"
    client_id     = $clientId
    client_secret = $clientSecret
    resource      = $resource
}

# Get the token (v1 endpoint; no extra content-type on purpose)
$response = Invoke-RestMethod -Method Post -Uri "https://login.microsoftonline.com/$tenantId/oauth2/token" -Body $body
$token    = $response.access_token

# Display/keep token + build headers exactly like in your snippet
$token
$headers = @{}
$headers.Add("Accept", "application/json")
$headers.Add("Authorization", "Bearer $token")

# (kept to mirror the screenshot; not used below)
$base64AuthInfo = [Convert]::ToBase64String([Text.Encoding]::ASCII.GetBytes(":$token"))

# -------- BASE URL --------
# Use AzOrgURL exactly as provided; just trim a trailing slash if present
if ($AzOrgURL.EndsWith("/")) { $AzOrgURL = $AzOrgURL.TrimEnd("/") }
$baseUri = "$AzOrgURL/_apis"

# -------- Helper --------
function Invoke-ADO {
    param([Parameter(Mandatory=$true)][string]$Uri)
    try {
        return Invoke-RestMethod -Method Get -Headers $headers -Uri $Uri -ErrorAction Stop
    }
    catch {
        Write-Warning "Request failed: $Uri"
        throw
    }
}

# -------- Smoke test --------
try {
    Invoke-RestMethod -Headers $headers -Uri "$baseUri/connectionData?api-version=7.1-preview.1" | Out-Null
}
catch {
    throw "Auth/org check failed. Ensure the service principal has access to the Azure DevOps organization and Agent Pools. $_"
}

# -------- Main: list pools and agents --------
$poolsUri = "$baseUri/distributedtask/pools?api-version=7.1-preview.1"
$pools    = (Invoke-ADO -Uri $poolsUri).value

if (-not $pools) {
    Write-Host "No agent pools found or insufficient permissions." -ForegroundColor Yellow
    return
}

$results = New-Object System.Collections.Generic.List[object]

foreach ($pool in $pools) {
    # Agents (include capabilities to infer image)
    $agentsUri   = "$baseUri/distributedtask/pools/$($pool.id)/agents?includeCapabilities=true&includeAssignedRequest=true&includeLastCompletedRequest=true&api-version=7.1-preview.1"
    $agentsValue = (Invoke-ADO -Uri $agentsUri).value

    # Online/offline counts
    $onlineCount  = ($agentsValue | Where-Object { $_.status -eq "online" }).Count
    $offlineCount = ($agentsValue | Where-Object { $_.status -ne "online" }).Count

    # Last used from job requests (fallback: agents' lastOnlineTime)
    $lastUsed = $null
    try {
        $jobReqUri = "$baseUri/distributedtask/pools/$($pool.id)/jobrequests?completedRequestCount=1&api-version=7.1-preview.1"
        $jobReq    = Invoke-ADO -Uri $jobReqUri

        $times = @()
        if ($jobReq.requests) {
            foreach ($r in $jobReq.requests) {
                if ($r.finishTime) { $times += [datetime]$r.finishTime }
                elseif ($r.startTime) { $times += [datetime]$r.startTime }
                elseif ($r.queueTime) { $times += [datetime]$r.queueTime }
            }
        }
        if (-not $times -and $agentsValue) {
            $times += ($agentsValue | Where-Object { $_.lastOnlineTime } | ForEach-Object { [datetime]$_.lastOnlineTime })
        }
        if ($times) { $lastUsed = ($times | Sort-Object -Descending | Select-Object -First 1) }
    } catch { }

    # Per-agent rows
    foreach ($agent in $agentsValue) {
        $cap = $agent.systemCapabilities
        $image =
            $cap.Image                         `
            ?? $cap.'ImageVersion'             `
            ?? $cap.'Agent.ImageName'          `
            ?? $cap.'HostedImage'              `
            ?? $cap.'Agent.OS'

        $results.Add([pscustomobject]@{
            Organization    = ($AzOrgURL -replace '^https?://', '')
            PoolName        = $pool.name
            PoolId          = $pool.id
            LastUsedUtc     = if ($lastUsed) { [datetime]::SpecifyKind($lastUsed, 'Utc').ToString("u") } else { $null }
            AgentsOnline    = $onlineCount
            AgentsOffline   = $offlineCount
            AgentName       = $agent.name
            AgentStatus     = $agent.status
            AgentOS         = $agent.osDescription
            AgentImage      = $image
            AgentVersion    = $agent.version
            AgentEnabled    = $agent.enabled
        })
    }

    # If a pool has no visible agents, still emit a summary row
    if (-not $agentsValue -or $agentsValue.Count -eq 0) {
        $results.Add([pscustomobject]@{
            Organization    = ($AzOrgURL -replace '^https?://', '')
            PoolName        = $pool.name
            PoolId          = $pool.id
            LastUsedUtc     = if ($lastUsed) { [datetime]::SpecifyKind($lastUsed, 'Utc').ToString("u") } else { $null }
            AgentsOnline    = 0
            AgentsOffline   = 0
            AgentName       = $null
            AgentStatus     = $null
            AgentOS         = $null
            AgentImage      = $null
            AgentVersion    = $null
            AgentEnabled    = $null
        })
    }
}

# -------- Output --------
$results | Sort-Object PoolName, AgentName | Format-Table -AutoSize

if ($OutCsv) {
    $results | Sort-Object PoolName, AgentName |
        Export-Csv -NoTypeInformation -Encoding UTF8 -Path $OutCsv
    Write-Host "Saved to $OutCsv" -ForegroundColor Green
}


##########################



# =========================
# Azure DevOps Agent Pools Inventory
# =========================
# Outputs one row per agent with pool-level stats and "last used" timestamp.
# Optional: set $OutCsv to a path to also save as CSV.

# --------- CONFIG ---------
$Organization = "your-org-name"          # e.g. "contoso"
$Pat          = "YOUR_PAT_HERE"           # PAT with Agent Pools (read/manage)
$OutCsv       = ""                        # e.g. "C:\temp\ado-agent-pools.csv" or leave blank to skip CSV
# --------------------------

# Build auth header
$baseUri = "https://dev.azure.com/$Organization/_apis"
$auth    = [Convert]::ToBase64String([Text.Encoding]::ASCII.GetBytes(":$Pat"))
$headers = @{ Authorization = "Basic $auth" }

# Helper: safely get a REST page
function Invoke-ADO {
    param(
        [Parameter(Mandatory=$true)][string]$Uri
    )
    try {
        return Invoke-RestMethod -Method Get -Headers $headers -Uri $Uri -ErrorAction Stop
    }
    catch {
        Write-Warning "Request failed: $Uri"
        throw
    }
}

# Find all pools
$poolsUri = "$baseUri/distributedtask/pools?api-version=7.1-preview.1"
$pools    = (Invoke-ADO -Uri $poolsUri).value

if (-not $pools) {
    Write-Host "No agent pools found or insufficient permissions." -ForegroundColor Yellow
    return
}

$results = New-Object System.Collections.Generic.List[object]

foreach ($pool in $pools) {
    # Get agents for this pool (include capabilities to infer image)
    $agentsUri   = "$baseUri/distributedtask/pools/$($pool.id)/agents?includeCapabilities=true&includeAssignedRequest=true&includeLastCompletedRequest=true&api-version=7.1-preview.1"
    $agentsValue = (Invoke-ADO -Uri $agentsUri).value

    # Compute online/offline counts
    $onlineCount  = ($agentsValue | Where-Object { $_.status -eq "online" }).Count
    $offlineCount = ($agentsValue | Where-Object { $_.status -ne "online" }).Count

    # Try to infer "last used" time for the pool:
    # Strategy: look at the pool's job requests (completed or assigned) and take the latest finish/start/queue time.
    $lastUsed = $null
    try {
        # completedRequestCount=1 asks service to include the most recent completed request (if any)
        $jobReqUri = "$baseUri/distributedtask/pools/$($pool.id)/jobrequests?completedRequestCount=1&api-version=7.1-preview.1"
        $jobReq    = Invoke-ADO -Uri $jobReqUri

        # jobReq.requests can contain current and the last completed request.
        $times = @()
        if ($jobReq.requests) {
            foreach ($r in $jobReq.requests) {
                if ($r.finishTime) { $times += [datetime]$r.finishTime }
                elseif ($r.startTime) { $times += [datetime]$r.startTime }
                elseif ($r.queueTime) { $times += [datetime]$r.queueTime }
            }
        }

        # Fallback: if nothing from requests, try agents' lastOnlineTime as weakest signal
        if (-not $times -and $agentsValue) {
            $times += ($agentsValue | Where-Object { $_.lastOnlineTime } | ForEach-Object { [datetime]$_.lastOnlineTime })
        }

        if ($times) {
            $lastUsed = ($times | Sort-Object -Descending | Select-Object -First 1)
        }
    }
    catch {
        # leave $lastUsed as $null if endpoint not permitted in your org/pool
    }

    # Build per-agent rows
    foreach ($agent in $agentsValue) {
        # Try to extract an "Image" from systemCapabilities
        $cap = $agent.systemCapabilities

        # Best-effort keys we commonly see
        $image =
            $cap.Image                             `
            ?? $cap.'ImageVersion'                 `
            ?? $cap.'Agent.ImageName'              `
            ?? $cap.'HostedImage'                  `
            ?? $cap.'Agent.OS'                     # last fallback: OS if no image label exists

        $osDesc = $agent.osDescription
        $agentStatus = $agent.status
        $agentName   = $agent.name

        $results.Add([pscustomobject]@{
            Organization    = $Organization
            PoolName        = $pool.name
            PoolId          = $pool.id
            LastUsedUtc     = if ($lastUsed) { [datetime]::SpecifyKind($lastUsed, 'Utc').ToString("u") } else { $null }
            AgentsOnline    = $onlineCount
            AgentsOffline   = $offlineCount
            AgentName       = $agentName
            AgentStatus     = $agentStatus
            AgentOS         = $osDesc
            AgentImage      = $image
            AgentVersion    = $agent.version
            AgentEnabled    = $agent.enabled
        })
    }

    # If a pool has no visible agents (e.g., only Microsoft-hosted), still emit a summary row
    if (-not $agentsValue -or $agentsValue.Count -eq 0) {
        $results.Add([pscustomobject]@{
            Organization    = $Organization
            PoolName        = $pool.name
            PoolId          = $pool.id
            LastUsedUtc     = if ($lastUsed) { [datetime]::SpecifyKind($lastUsed, 'Utc').ToString("u") } else { $null }
            AgentsOnline    = 0
            AgentsOffline   = 0
            AgentName       = $null
            AgentStatus     = $null
            AgentOS         = $null
            AgentImage      = $null
            AgentVersion    = $null
            AgentEnabled    = $null
        })
    }
}

# Output to console
$results | Sort-Object PoolName, AgentName | Format-Table -AutoSize

# Optional CSV
if ($OutCsv) {
    $results | Sort-Object PoolName, AgentName | Export-Csv -NoTypeInformation -Encoding UTF8 -Path $OutCsv
    Write-Host "Saved to $OutCsv" -ForegroundColor Green
}


#############


# Get Namespace/Pod/Container + the pulled image digest (sha256)
$pods = kubectl get pods -A -o json | ConvertFrom-Json

$rows = foreach ($p in $pods.items) {
  $ns  = $p.metadata.namespace
  $pod = $p.metadata.name

  $statuses = @()
  foreach ($k in 'initContainerStatuses','containerStatuses','ephemeralContainerStatuses') {
    if ($p.status.$k) { $statuses += $p.status.$k }
  }

  foreach ($s in $statuses) {
    $id = $s.imageID
    $digest = ''
    if ($id) {
      $id = $id -replace '^(docker-pullable|docker|containerd)://',''
      if ($id -like '*@*')       { $digest = $id.Split('@')[-1] }
      elseif ($id -match '^sha256:[0-9a-fA-F]+$') { $digest = $id }
    }

    [pscustomobject]@{
      Namespace = $ns
      Pod       = $pod
      Container = $s.name
      Digest    = $digest
    }
  }
}

$rows | Sort-Object Namespace,Pod,Container | Format-Table -AutoSize
# Export if you want:
# $rows | Export-Csv .\pod-image-digests_minimal.csv -NoTypeInformation -Encoding UTF8




###sha
kubectl get pods -A -o json | jq -r '
  def digest_from_imageid:
    ( . // "" 
      | gsub("^docker-pullable://|^docker://|^containerd://"; "")
      | if contains("@") then (split("@")|.[1])
        elif test("^sha256:[0-9a-fA-F]+$") then .
        else "" end );
  .items[] as $p
  | ($p.status.initContainerStatuses // [] 
     + $p.status.containerStatuses // [] 
     + $p.status.ephemeralContainerStatuses // [])[]?
  | [
      $p.metadata.namespace,
      $p.metadata.name,
      .name,
      (.imageID | digest_from_imageid)
    ]
  | @tsv
' | column -t


#############

kubectl get pods -A -o json | jq -r '
  def digest_from_imageid:
    ( . // "" 
      | gsub("^docker-pullable://|^docker://|^containerd://"; "")
      | if contains("@") then (split("@")|.[1])
        elif test("^sha256:[0-9a-fA-F]+$") then .
        else "" end );
  def parse_image:
    capture("^(?:(?<registry>[^/]+)/)?(?<repo>(?:[^/@:]+/)*[^/@:]+)(?::(?<tag>[^@]+))?") // {};
  .items[] as $p
  | ($p.status.initContainerStatuses // [] 
     + $p.status.containerStatuses // [] 
     + $p.status.ephemeralContainerStatuses // [])[]?
  | (.image | parse_image) as $img
  | [
      $p.metadata.namespace,
      $p.metadata.name,
      .name,
      ($img.registry // ""),
      ($img.repo // ""),
      ($img.tag // ""),
      (.imageID | digest_from_imageid)
    ]
  | @csv
' > pod-image-digests.csv
#######################################################
kubectl get pods -A \
  -o custom-columns=NS:.metadata.namespace,POD:.metadata.name,CONTAINERS:.spec.containers[*].name,IMAGES:.spec.containers[*].image,DIGESTS:.status.containerStatuses[*].imageID \
  --no-headers






############################################











Easiest: use kubectl (works the same for AKS). First make sure youâ€™re on the right cluster:

az aks get-credentials -g <RESOURCE_GROUP> -n <AKS_CLUSTER_NAME> --overwrite-existing
kubectl config current-context

Quick one-liner (all pods, all namespaces)
kubectl get pods -A \
  -o custom-columns=NAMESPACE:.metadata.namespace,POD:.metadata.name,IMAGES:.spec.containers[*].image \
  --no-headers


Shows each pod and the image(s) of its regular containers (comma-separated if multiple).

Include init + ephemeral containers too (more complete)
kubectl get pods -A -o json | jq -r '
  .items[] as $p |
  ($p.metadata.namespace + "\t" + $p.metadata.name + "\t" +
   ([
      ($p.spec.initContainers[]?.image),
      ($p.spec.containers[]?.image),
      ($p.spec.ephemeralContainers[]?.image)
    ] | map(select(. != null)) | unique | join(",")))
'

Save to CSV
kubectl get pods -A \
  -o custom-columns=NAMESPACE:.metadata.namespace,POD:.metadata.name,IMAGES:.spec.containers[*].image \
  --no-headers > pod-images.csv

(Optional) If you actually want images by workload (Deployments, etc.)
kubectl get deploy -A \
  -o custom-columns=NAMESPACE:.metadata.namespace,DEPLOYMENT:.metadata.name,IMAGES:.spec.template.spec.containers[*].image \
  --no-headers



AzureDiagnostics
| where Resource == "<FIREWALL_NAME>" or FirewallPolicyName_s == "<FIREWALL_POLICY_NAME>"
| where Category in ("AzureFirewallApplicationRule", "AzureFirewallNetworkRule", "AzureFirewallNatRule")
| where TimeGenerated > ago(7d)  // Optional: last 7 days
| summarize Hits = count() by RuleCollectionName_s, RuleName_s, Category
| order by Hits desc


















# Disable FTP Basic Auth Publishing Credentials
az resource update \
  --resource-group "<RESOURCE_GROUP>" \
  --namespace Microsoft.Web \
  --resource-type basicPublishingCredentialsPolicies \
  --parent "sites/<FUNCTION_APP_NAME>" \
  --name ftp \
  --set properties.allow=false

# Disable SCM Basic Auth Publishing Credentials (the Kudu/Git/ZIP endpoint)
az resource update \
  --resource-group "<RESOURCE_GROUP>" \
  --namespace Microsoft.Web \
  --resource-type basicPublishingCredentialsPolicies \
  --parent "sites/<FUNCTION_APP_NAME>" \
  --name scm \
  --set properties.allow=false








########################################################



# Variables â€“ update to your environment
$rgName      = "myResourceGroup"
$galleryName = "myGallery"

# Get all image definitions in the gallery
$definitions = Get-AzGalleryImageDefinition `
    -ResourceGroupName $rgName `
    -GalleryName $galleryName

foreach ($def in $definitions) {
    Write-Host "Processing Image Definition: $($def.Name)" -ForegroundColor Cyan

    # Fetch all versions, sorting newest first by PublishedDate
    $versions = Get-AzGalleryImageVersion `
        -ResourceGroupName $rgName `
        -GalleryName $galleryName `
        -GalleryImageDefinitionName $def.Name |
      Sort-Object { $_.PublishingProfile.PublishedDate } -Descending

    # Determine which to delete (skip the first 5)
    $toDelete = $versions | Select-Object -Skip 5

    if ($toDelete.Count -eq 0) {
        Write-Host "  No old versions to remove. Keeping all." -ForegroundColor Green
    }
    else {
        foreach ($v in $toDelete) {
            $name  = $v.Name
            $date  = $v.PublishingProfile.PublishedDate
            Write-Host "  Deleting version '$name' published on $date" -ForegroundColor Yellow

            # Remove it
            Remove-AzGalleryImageVersion `
                -ResourceGroupName $rgName `
                -GalleryName $galleryName `
                -GalleryImageDefinitionName $def.Name `
                -Name $name `
                -Force
        }
    }
}


az account set --subscription "Your Subscription Name or ID"
az keyvault show --name "myUniqueKeyVault" --resource-group "myResourceGroup" --query "properties.sku.name" --output tsv
az keyvault update --name "myUniqueKeyVault" --resource-group "myResourceGroup" --set properties.sku.name=Premium
az keyvault show --name "myUniqueKeyVault" --resource-group "myResourceGroup" --query "properties.sku.name" --output tsv



#!/bin/bash

# --- Configuration ---
RESOURCE_GROUP_NAME="myResourceGroup"  # Replace with your resource group name
KEY_VAULT_NAME="myUniqueKeyVault"      # Replace with your Key Vault name

# --- Get Key Vault details and check SKU ---
echo "Getting details for Key Vault: $KEY_VAULT_NAME in resource group: $RESOURCE_GROUP_NAME"

key_vault_sku=$(az keyvault show \
    --name "$KEY_VAULT_NAME" \
    --resource-group "$RESOURCE_GROUP_NAME" \
    --query "properties.sku.name" \
    --output tsv 2>/dev/null) # Redirect stderr to /dev/null to suppress "not found" errors initially

if [ -z "$key_vault_sku" ]; then
    echo "Error: Key Vault '$KEY_VAULT_NAME' not found in resource group '$RESOURCE_GROUP_NAME'."
    exit 1
fi

echo "Current Key Vault SKU: $key_vault_sku"

if [ "$key_vault_sku" = "Premium" ]; then
    echo "Key Vault '$KEY_VAULT_NAME' is already set to Premium tier. No action needed."
else
    echo "Key Vault '$KEY_VAULT_NAME' is currently '$key_vault_sku' tier. Upgrading to Premium..."
    az keyvault update \
        --name "$KEY_VAULT_NAME" \
        --resource-group "$RESOURCE_GROUP_NAME" \
        --set properties.sku.name=Premium

    if [ $? -eq 0 ]; then
        echo "Successfully upgraded Key Vault '$KEY_VAULT_NAME' to Premium tier."
    else
        echo "Error: Failed to upgrade Key Vault '$KEY_VAULT_NAME' to Premium tier."
        exit 1
    fi
fi

# Optional: Verify the SKU after update
echo "Verifying Key Vault SKU after potential update..."
updated_key_vault_sku=$(az keyvault show \
    --name "$KEY_VAULT_NAME" \
    --resource-group "$RESOURCE_GROUP_NAME" \
    --query "properties.sku.name" \
    --output tsv)

echo "Final Key Vault SKU: $updated_key_vault_sku"

if [ "$updated_key_vault_sku" = "Premium" ]; then
    echo "Confirmation: Key Vault '$KEY_VAULT_NAME' is indeed Premium."
else
    echo "Warning: Key Vault '$KEY_VAULT_NAME' is not Premium after the operation. Please investigate."
fi





# Create the custom role
az role definition create \
  --role-definition approve-private-databricks-connections.json

# Assign it to a user, service principal, or managed identity
az role assignment create \
  --assignee <user-or-spn> \
  --role "approve-private-connections" \
  --scope /subscriptions/<your-subscription-id>/resourceGroups/<rg-name>


{
  "Name": "approve-private-connections",
  "IsCustom": true,
  "Description": "Can list and approve only Azure Databricks Private Endpoint connections",
  "Actions": [
    "Microsoft.Databricks/workspaces/privateEndpointConnections/read",
    "Microsoft.Databricks/workspaces/privateEndpointConnectionsApproval/action"
  ],
  "NotActions": [],
  "DataActions": [],
  "NotDataActions": [],
  "AssignableScopes": [
    "/subscriptions/<your-subscription-id>"
  ]
}





$accessToken = (Get-AzAccessToken -ResourceUrl "https://management.azure.com/").Token
$headers = @{
    "Authorization" = "Bearer $accessToken"
    "Content-Type" = "application/json" # Though not strictly required for DELETE, good practice
}


# 1. Grab an access token from the MSI endpoint
$msiUrl = 'http://169.254.169.254/metadata/identity/oauth2/token' +
          '?api-version=2019-08-01&resource=https://vault.azure.net'
$token = (Invoke-RestMethod `
  -Method GET `
  -Uri    $msiUrl `
  -Headers @{ Metadata = 'true' } `
).access_token

# 2. Call Key Vault to fetch the secret
$vaultName  = '<YourVaultName>'
$secretName = '<YourSecretName>'

$kvUrl = "https://$vaultName.vault.azure.net/secrets/$secretName?api-version=7.0"
$secret = (Invoke-RestMethod `
  -Method GET `
  -Uri    $kvUrl `
  -Headers @{ Authorization = "Bearer $token" } `
).value

# 3. Output the secret
$secret


#########################################
<#
.SYNOPSIS
  Enumerate all service connections used by every release in every project.

.DESCRIPTION
  - Pulls all projects from https://dev.azure.com/{org}/_apis/projects
  - Pulls all releases from https://vsrm.dev.azure.com/{org}/{project}/_apis/release/releases
  - For each release, expands artifacts to see .definitionReference.connection

.REQUIREMENTS
  - PowerShell 7+ (for Invoke-WebRequest headers handling)
  - AZDO_ORG and AZDO_PAT set in the environment, or fill in below.

.EXAMPLE
  PS> $env:AZDO_ORG = 'my-org'
  PS> $env:AZDO_PAT = 'xxxxxxxxxxxx'
  PS> ./Get-AllServiceConnections.ps1
#>

# â€”â€” CONFIGURATION â€”â€”
# Either set these as env vars, or hard-code here:
$Organization = $env:AZDO_ORG      # e.g. "my-azure-org"
$Pat          = $env:AZDO_PAT      # your Personal Access Token
$ApiVersion   = "7.2"

if (-not $Organization -or -not $Pat) {
    Write-Error "Please set AZDO_ORG and AZDO_PAT (or fill in the script)."
    exit 1
}

# Prepare Basic auth header
$base64AuthInfo = [Convert]::ToBase64String(
    [Text.Encoding]::ASCII.GetBytes(":$Pat")
)
$AuthHeader = @{ Authorization = "Basic $base64AuthInfo" }

function Get-AllProjects {
    $baseUrl = "https://dev.azure.com/$Organization/_apis/projects?api-version=$ApiVersion"
    $continuationToken = $null

    do {
        # Append continuationToken if present
        $uri = if ($continuationToken) {
            "$baseUrl&continuationToken=$continuationToken"
        } else {
            $baseUrl
        }

        $resp = Invoke-WebRequest -Uri $uri -Headers $AuthHeader -UseBasicParsing
        $json = $resp.Content | ConvertFrom-Json

        foreach ($proj in $json.value) {
            $proj.name
        }

        $continuationToken = $resp.Headers["x-ms-continuationtoken"]
    } while ($continuationToken)
}

function Get-AllReleases {
    param($ProjectName)
    $baseUrl = "https://vsrm.dev.azure.com/$Organization/$ProjectName/_apis/release/releases?api-version=$ApiVersion&`$top=100"
    $continuationToken = $null

    do {
        $uri = if ($continuationToken) {
            "$baseUrl&continuationToken=$continuationToken"
        } else {
            $baseUrl
        }

        $resp = Invoke-WebRequest -Uri $uri -Headers $AuthHeader -UseBasicParsing
        $json = $resp.Content | ConvertFrom-Json

        foreach ($rel in $json.value) {
            $rel.id
        }

        $continuationToken = $resp.Headers["x-ms-continuationtoken"]
    } while ($continuationToken)
}

function Get-ReleaseWithArtifacts {
    param(
        [string]$ProjectName,
        [int]$ReleaseId
    )

    $uri = "https://vsrm.dev.azure.com/$Organization/$ProjectName/_apis/release/releases/$ReleaseId?api-version=$ApiVersion&`$expand=artifacts"
    $resp = Invoke-WebRequest -Uri $uri -Headers $AuthHeader -UseBasicParsing
    return ($resp.Content | ConvertFrom-Json)
}

# â€”â€” MAIN LOOP â€”â€”
Write-Host "Scanning organization '$Organization'..." -ForegroundColor Cyan

foreach ($projName in Get-AllProjects) {
    Write-Host "`nProject: $projName" -ForegroundColor Yellow

    foreach ($relId in Get-AllReleases -ProjectName $projName) {
        $release = Get-ReleaseWithArtifacts -ProjectName $projName -ReleaseId $relId
        Write-Host "  Release ID: $relId"

        foreach ($artifact in $release.artifacts) {
            $conn = $artifact.definitionReference.connection
            if ($conn) {
                Write-Host "    âž¤ Service Connection ID: $($conn.id)"
                Write-Host "      Name:               $($conn.name)"
            }
        }
    }
}

Write-Host "`nDone." -ForegroundColor Green






















############################################################################################################
# Requires: PowerShell 7+, Install-Module powershell-yaml
param(
    [Parameter(Mandatory)][string]$Organization,   # e.g. "https://dev.azure.com/contoso"
    [Parameter(Mandatory)][string]$Project,        # e.g. "MyProject"
    [Parameter(Mandatory)][int]   $DefinitionId,   # pipeline ID
    [Parameter(Mandatory)][string]$PAT             # Personal Access Token
)

# --- Setup auth header ---
$base64Auth = [Convert]::ToBase64String([Text.Encoding]::ASCII.GetBytes(":$PAT"))
$headers    = @{ Authorization = "Basic $base64Auth" }
$apiVersion = "6.0"

# --- 1) Get pipeline definition metadata ---
$defUrl = "$Organization/$Project/_apis/build/definitions/$DefinitionId?api-version=$apiVersion"
$def    = Invoke-RestMethod -Uri $defUrl -Headers $headers

# Prepare a collection for service-connection references
$svcRefs = [System.Collections.Generic.HashSet[string]]::new()

if ($def.process.type -eq 1) {
    #
    # Classic pipeline: tasks embedded in the JSON
    #
    Write-Host "Detected Classic definition. Scanning tasks for service-connection inputs..." -ForegroundColor Cyan

    # Walk all phases & steps
    foreach ($phase in $def.process.phases) {
        foreach ($step in $phase.steps) {
            # Typical input names that hold service connections
            foreach ($field in 'azureSubscription','connectedServiceName','serviceConnection','serviceEndpoint') {
                if ($step.inputs.ContainsKey($field)) {
                    $svcRefs.Add($step.inputs[$field]) | Out-Null
                }
            }
        }
    }
}
else {
    #
    # YAML pipeline: need to fetch the YAML file from the repo
    #
    Write-Host "Detected YAML definition. Fetching YAML ($($def.process.yamlFilename))..." -ForegroundColor Cyan

    $repoId   = $def.repository.id
    $yamlPath = $def.process.yamlFilename

    $yamlUrl  = "$Organization/$Project/_apis/git/repositories/$repoId/items?path=$($yamlPath -replace ' ','%20')&includeContent=true&api-version=$apiVersion"
    $yamlResp = Invoke-RestMethod -Uri $yamlUrl -Headers $headers

    # Parse YAML (Install-Module powershell-yaml if you haven't already)
    Import-Module powershell-yaml -ErrorAction Stop
    $yamlObj = ConvertFrom-Yaml $yamlResp.content

    # Look under `steps:` recursively for any inputs
    function Scan-Steps {
        param($steps)
        foreach ($s in $steps) {
            if ($s.inputs) {
                foreach ($field in 'azureSubscription','connectedServiceName','serviceConnection','serviceEndpoint') {
                    if ($s.inputs.ContainsKey($field)) {
                        $svcRefs.Add($s.inputs[$field]) | Out-Null
                    }
                }
            }
            # nested job/template/include handling
            if ($s.steps) { Scan-Steps -steps $s.steps }
        }
    }

    if ($yamlObj.steps)    { Scan-Steps -steps $yamlObj.steps }
    if ($yamlObj.jobs)     { foreach ($j in $yamlObj.jobs) { if ($j.steps) { Scan-Steps -steps $j.steps } } }
    if ($yamlObj.stages)   { foreach ($st in $yamlObj.stages) {
                                if ($st.jobs) { foreach ($j in $st.jobs) {
                                                    if ($j.steps) { Scan-Steps -steps $j.steps }
                                                } }
                             } }
}

# --- 3) Output results ---
if ($svcRefs.Count -gt 0) {
    Write-Host "`nService connections referenced by pipeline #$DefinitionId:" -ForegroundColor Green
    $svcRefs | Sort-Object
}
else {
    Write-Host "`nNo service-connection inputs found in this pipeline." -ForegroundColor Yellow
}












##########################################################################################################
<#
.SYNOPSIS
  Classify Azure DevOps pipelines (YAML & classic) as Prod vs Non-Prod,
  catching variants like production/Production/prd/pr, nonprod/non-prod/np.

.PARAMETER OrgUrl
  Your Azure DevOps org URL, e.g. https://dev.azure.com/YourOrg
#>

param(
  [Parameter(Mandatory)]
  [string] $OrgUrl
)

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Prerequisites:
#   az extension add --name azure-devops
#   az login
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

# point CLI at your org
az devops configure --defaults organization=$OrgUrl > $null

# regexes for matching
$prodRegex    = '(?i)\b(?:production|prod|prd|pr)\b'
$nonProdRegex = '(?i)\b(?:non[-]?prod|np)\b'

# output CSV header
"Project,Type,ID,Name,Prod?,Marker"

# get all projects
$projects = az devops project list --query "value[].name" -o tsv

foreach ($proj in $projects) {

  # â€” 1) YAML pipelines â€”
  $yamlList = az pipelines list --project $proj -o json | ConvertFrom-Json
  foreach ($pipe in $yamlList) {
    $id    = $pipe.id
    $name  = $pipe.name
    $det   = az pipelines show --project $proj --id $id -o json | ConvertFrom-Json
    $path  = $det.configuration.path

    if    ($path   -match $prodRegex)    { $label = 'Prod' }
    elseif($path   -match $nonProdRegex) { $label = 'Non-Prod' }
    else                                   { $label = 'Non-Prod' }

    "$proj,YAML,$id,`"$name`",$label,`"$path`""
  }

  # â€” 2) Classic Build definitions â€”
  $builds = az pipelines build definition list --project $proj -o json | ConvertFrom-Json
  foreach ($bd in $builds) {
    $id     = $bd.id
    $name   = $bd.name
    $folder = $bd.path
    $envVar = if ($bd.variables.Environment) { $bd.variables.Environment.value } else { '' }
    $tags   = if ($bd.tags) { $bd.tags -join ';' } else { '' }
    $marker = ($folder, $envVar, $tags | Where-Object { $_ }) -join ';'

    if    ($folder -match $prodRegex -or $envVar -match $prodRegex -or $tags -match $prodRegex) {
      $label = 'Prod'
    }
    elseif($folder -match $nonProdRegex -or $envVar -match $nonProdRegex -or $tags -match $nonProdRegex) {
      $label = 'Non-Prod'
    }
    else {
      $label = 'Non-Prod'
    }

    "$proj,Build,$id,`"$name`",$label,`"$marker`""
  }

  # â€” 3) Classic Release definitions â€”
  $releases = az pipelines release definition list --project $proj -o json | ConvertFrom-Json
  foreach ($rd in $releases) {
    $id      = $rd.id
    $name    = $rd.name
    $envNames= $rd.environments | ForEach-Object { $_.name }
    $marker  = $envNames -join ';'
    
    if    ($marker -match $prodRegex)    { $label = 'Prod' }
    elseif($marker -match $nonProdRegex) { $label = 'Non-Prod' }
    else                                   { $label = 'Non-Prod' }

    "$proj,Release,$id,`"$name`",$label,`"$marker`""
  }
}


+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++



# Retrieve required environment variables (set these in your Function App Application Settings)
$organization = $env:DEVOPS_ORGANIZATION    # e.g., "myorg"
$pat = $env:DEVOPS_PAT                      # Your Personal Access Token

# Validate environment variables are set
if (-not $organization -or -not $pat) {
    Write-Error "DEVOPS_ORGANIZATION and DEVOPS_PAT must be set in application settings."
    exit 1
}

# Prepare the authentication header for Azure DevOps REST API
$base64AuthInfo = [Convert]::ToBase64String([Text.Encoding]::ASCII.GetBytes(":$pat"))
$authHeader = @{ Authorization = "Basic $base64AuthInfo" }

# Define the base API version and URL 
$apiVersion = "6.0"
$projectsApiUrl = "https://dev.azure.com/$organization/_apis/projects?api-version=$apiVersion"

try {
    # Retrieve all projects in the organization
    $projectsResponse = Invoke-RestMethod -Uri $projectsApiUrl -Method Get -Headers $authHeader
    $projects = $projectsResponse.value
    Write-Output "Retrieved $($projects.Count) projects from organization '$organization'."
}
catch {
    Write-Error "Error retrieving projects: $_"
    exit 1
}

# Loop through each project to get successful build runs and their logs
foreach ($project in $projects) {
    $projectName = $project.name
    Write-Output "Processing project: $projectName"

    # URL to get builds for the project.
    # The filters:
    #   statusFilter=completed ensures only finished builds are returned.
    #   resultFilter=succeeded ensures only succeeded runs are returned.
    $buildsApiUrl = "https://dev.azure.com/$organization/$projectName/_apis/build/builds?statusFilter=completed&resultFilter=succeeded&api-version=$apiVersion"
    
    try {
        $buildsResponse = Invoke-RestMethod -Uri $buildsApiUrl -Method Get -Headers $authHeader
        $builds = $buildsResponse.value
        Write-Output "  Found $($builds.Count) successful build(s) in project '$projectName'."
    }
    catch {
        Write-Error "Error retrieving builds for project '$projectName': $_"
        continue
    }

    # Process each successful build
    foreach ($build in $builds) {
        $buildId = $build.id
        Write-Output "  Retrieving logs for Build ID: $buildId"

        # URL to get logs (list of log files) for the build
        $logsApiUrl = "https://dev.azure.com/$organization/$projectName/_apis/build/builds/$buildId/logs?api-version=$apiVersion"
        
        try {
            $logsResponse = Invoke-RestMethod -Uri $logsApiUrl -Method Get -Headers $authHeader
        }
        catch {
            Write-Error "    Error retrieving logs for Build ID $buildId in project '$projectName': $_"
            continue
        }
        
        # Loop through each log item (each log file may represent one step or task)
        foreach ($logItem in $logsResponse.value) {
            $logId = $logItem.id
            # Retrieve the content of the log
            $logContentUrl = "https://dev.azure.com/$organization/$projectName/_apis/build/builds/$buildId/logs/$logId?api-version=$apiVersion"
            
            try {
                $logContent = Invoke-RestMethod -Uri $logContentUrl -Method Get -Headers $authHeader
                Write-Output "    --- Log for Build $buildId (Log ID: $logId) ---"
                Write-Output $logContent
                Write-Output "    --- End Log ---`n"
            }
            catch {
                Write-Error "    Error retrieving content for log ID $logId for Build ID $buildId: $_"
            }
        }
    }
}

##############################################################################
terraform {
  required_providers {
    azurerm = {
      source  = "hashicorp/azurerm"
      version = "~> 3.0"
    }
  }
}

provider "azurerm" {
  features {}
}

# Resource Group
resource "azurerm_resource_group" "rg" {
  name     = "rg-umi-eventgrid"
  location = "East US"
}

# User Assigned Managed Identity (UMI)
resource "azurerm_user_assigned_identity" "umi" {
  name                = "umi-example"
  resource_group_name = azurerm_resource_group.rg.name
  location            = azurerm_resource_group.rg.location
}

# Service Bus Namespace
resource "azurerm_servicebus_namespace" "sbns" {
  name                = "sbnsumiexample"
  location            = azurerm_resource_group.rg.location
  resource_group_name = azurerm_resource_group.rg.name
  sku                 = "Standard"
}

# Service Bus Queue
resource "azurerm_servicebus_queue" "queue" {
  name                = "queueumi"
  resource_group_name = azurerm_resource_group.rg.name
  namespace_name      = azurerm_servicebus_namespace.sbns.name
}

# Role Assignment: Grant the UMI the Service Bus Data Sender role on the namespace
resource "azurerm_role_assignment" "umi_sb_data_sender" {
  scope                = azurerm_servicebus_namespace.sbns.id
  role_definition_name = "Azure Service Bus Data Sender"
  principal_id         = azurerm_user_assigned_identity.umi.principal_id
}

# Event Grid Topic (to publish events)
resource "azurerm_eventgrid_topic" "eg_topic" {
  name                = "egtopicumi"
  location            = azurerm_resource_group.rg.location
  resource_group_name = azurerm_resource_group.rg.name
}

# Event Grid Event Subscription using UMI for authentication
resource "azurerm_eventgrid_event_subscription" "eg_subscription" {
  name  = "egs-usiqueue"
  scope = azurerm_eventgrid_topic.eg_topic.id

  destination {
    endpoint_type = "ServiceBusQueue"
    resource_id   = azurerm_servicebus_queue.queue.id
  }

  # This block configures the subscription to use the UMI for AAD tokenâ€“based auth
  delivery_identity {
    user_assigned_identity_id = azurerm_user_assigned_identity.umi.id
  }

  # Optional filtering configuration; adjust as needed
  filter {
    is_subject_case_sensitive = false
  }

  event_delivery_schema = "EventGridSchema"
}




variable "powerplatform_service_connections" {
  type = list(object({
    name           = string
    environment_id = string
    server_url     = string
  }))
  default = []
}
##################################tenant_id               = "00000000-0000-0000-0000-000000000000"
client_id               = "11111111-1111-1111-1111-111111111111"
client_secret           = "MYCLIENTSECRET"
organization_name       = "myorg"
project_name            = "MyProject"
service_connection_name = "PowerPlatformAADServiceConn"
environment_id          = "ENV_GUID"
server_url              = "https://myorg.crm.dynamics.com"

####################################
create_service_connection.ps1.tpl
#########################################################

variable "tenant_id" {
  type        = string
  description = "Azure AD tenant ID"
}

variable "client_id" {
  type        = string
  description = "Azure AD client ID (service principal)"
}

variable "client_secret" {
  type        = string
  sensitive   = true
  description = "Service principal secret"
}

variable "organization_name" {
  type        = string
  description = "Azure DevOps organization name (e.g. 'myorg' if your DevOps URL is https://dev.azure.com/myorg)"
}

variable "project_name" {
  type        = string
  description = "Azure DevOps project name"
}

variable "service_connection_name" {
  type        = string
  description = "Name of the service connection to create"
}

variable "environment_id" {
  type        = string
  description = "Power Platform environment ID"
}

variable "server_url" {
  type        = string
  description = "Power Platform server URL (e.g. https://myorg.crm.dynamics.com)"
}

######################################################
variable "powerplatform_service_connections" {
  type = list(object({
    name           = string
    environment_id = string
    server_url     = string
  }))
  default = []
}

resource "null_resource" "create_power_platform_service_connections" {
  for_each = { for c in var.powerplatform_service_connections : c.name => c }

  provisioner "local-exec" {
    interpreter = ["/usr/bin/env", "pwsh", "-Command"]

    command = templatefile("${path.module}/create_service_connection.ps1.tpl", {
      tenant_id               = var.tenant_id
      client_id               = var.client_id
      client_secret           = var.client_secret
      organization_name       = var.organization_name
      project_name            = var.project_name
      service_connection_name = each.value.name
      environment_id          = each.value.environment_id
      server_url              = each.value.server_url
    })
  }
}
powerplatform_service_connections = [
  {
    name           = "Connection1"
    environment_id = "env-guid-1"
    server_url     = "https://org1.crm.dynamics.com"
  },
  {
    name           = "Connection2"
    environment_id = "env-guid-2"
    server_url     = "https://org2.crm.dynamics.com"
  }
]

@"
pwsh -NoProfile -NonInteractive -Command '
param(
  [Parameter(Mandatory=$true)][string]$TenantId,
  [Parameter(Mandatory=$true)][string]$ClientId,
  [Parameter(Mandatory=$true)][string]$ClientSecret,
  [Parameter(Mandatory=$true)][string]$OrgName,
  [Parameter(Mandatory=$true)][string]$ProjectName,
  [Parameter(Mandatory=$true)][string]$SvcConnName,
  [Parameter(Mandatory=$true)][string]$PowerEnvId,
  [Parameter(Mandatory=$true)][string]$ServerUrl
)

try {
  Write-Host "Authenticating to Azure DevOps with client credentials..."
  # 1) Request a token from AAD for the DevOps resource
  #    resource = 499b84ac-1321-427f-aa17-267ca6975798
  $tokenUrl = "https://login.microsoftonline.com/$TenantId/oauth2/token"
  $body = @{
    grant_type    = "client_credentials"
    client_id     = $ClientId
    client_secret = $ClientSecret
    resource      = "499b84ac-1321-427f-aa17-267ca6975798"
  }
  $tokenResponse = Invoke-RestMethod -Method Post -Uri $tokenUrl -Body $body
  $accessToken = $tokenResponse.access_token

  $headers = @{
    "Authorization" = "Bearer $accessToken"
    "Accept"        = "application/json"
  }

  # 2) Check if service connection already exists
  $checkUrl = "https://dev.azure.com/$OrgName/$ProjectName/_apis/serviceendpoint/endpoints?api-version=7.0-preview.2"
  $existing = (Invoke-RestMethod -Uri $checkUrl -Method GET -Headers $headers).value | Where-Object { $_.name -eq $SvcConnName }
  if ($existing) {
    Write-Host "Service connection '$SvcConnName' already exists. Skipping creation."
    return
  }

  # 3) Build the request body for a Power Platform service connection
  $bodyObject = @{
    name = $SvcConnName
    type = "powerPlatform"
    url  = $ServerUrl
    authorization = @{
      scheme     = "ServicePrincipal"
      parameters = @{
        TenantId     = $TenantId
        ClientId     = $ClientId
        ClientSecret = $ClientSecret
      }
    }
    data = @{
      EnvironmentId   = $PowerEnvId
      EnvironmentType = "Production"
      ServerUrl       = $ServerUrl
    }
    description = "Service Connection for Power Platform (via AAD client credentials)"
  }
  $jsonBody = $bodyObject | ConvertTo-Json -Depth 10

  # 4) Create the new service connection
  $createUrl = "https://dev.azure.com/$OrgName/$ProjectName/_apis/serviceendpoint/endpoints?api-version=7.0-preview.2"
  $response = Invoke-RestMethod -Uri $createUrl -Method POST -Headers $headers -ContentType "application/json" -Body $jsonBody

  Write-Host "Service connection '$SvcConnName' created successfully."
}
catch {
  Write-Error "Error: $($_.Exception.Message)"
  exit 1
}
' -TenantId '${tenant_id}' `
  -ClientId '${client_id}' `
  -ClientSecret '${client_secret}' `
  -OrgName '${organization_name}' `
  -ProjectName '${project_name}' `
  -SvcConnName '${service_connection_name}' `
  -PowerEnvId '${environment_id}' `
  -ServerUrl '${server_url}'
"@








@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@



tenant_id               = "00000000-0000-0000-0000-000000000000"
client_id               = "11111111-1111-1111-1111-111111111111"
client_secret           = "MYCLIENTSECRET"
organization_name       = "myorg"
project_name            = "MyProject"
service_connection_name = "PowerPlatformAADServiceConn"
environment_id          = "ENV_GUID"
server_url              = "https://myorg.crm.dynamics.com"
