- task: AzurePowerShell@5
  displayName: 'Share Service Connection'
  inputs:
    azureSubscription: 'sandpit-01-vsts'
    ScriptType: InlineScript
    Inline: |
      # Navigate to the scripts directory
      cd /scripts

      # Run Get-TableContents.ps1 to retrieve the table data
      $output = ./Get-TableContents.ps1 -ResourceGroupName "sandpit-01-rg-dev-01" `
                                         -StorageAccountName "sandpitsa" `
                                         -TableName "demo" `
                                         -TableOnly $true

      # Validate if $output has data
      if (-not $output) {
          Write-Error "No data retrieved from Get-TableContents.ps1. Ensure the table exists and has valid data."
          exit 1
      }

      # Debug: Log the structure of $output
      Write-Host "DEBUG: Output from Get-TableContents.ps1:"
      Write-Host ($output | ConvertTo-Json -Depth 3)

      # Iterate through each row in the output
      foreach ($row in $output) {
          # Extract SPN, Project Names, and Project IDs
          $spn = $row.spn
          $projectNames = $row.project_name_to_share_with -split ","
          $projectIds = $row.project_id_to_share_with -split ","

          Write-Host "Processing Service Connection: $spn"

          # Ensure project names and IDs match in length
          if ($projectNames.Length -ne $projectIds.Length) {
              Write-Error "Mismatch between project names and IDs for SPN: $spn"
              continue
          }

          # Process each project for the current SPN
          for ($i = 0; $i -lt $projectNames.Length; $i++) {
              $projectName = $projectNames[$i]
              $projectId = $projectIds[$i]

              # Escape special characters for logging
              Write-Host ("Sharing Service Connection {0} with Project {1} ({2})" -f $spn, $projectName, $projectId)

              # Call Share-ServiceConnection.ps1
              ./Share-ServiceConnection.ps1 -PatToken $(patToken) `
                                             -AzOrgURL "https://dev.azure.com/your-org" `
                                             -AzProject "Sandpit.DevTest" `
                                             -AzSCName $spn `
                                             -ProjectNameToShareWith $projectName `
                                             -ProjectIdToShareWith $projectId
          }
      }
    azurePowerShellVersion: LatestVersion


#################################################




















- task: AzurePowerShell@5
  displayName: 'Share Service Connection'
  inputs:
    azureSubscription: 'sandpit-01-vsts'
    ScriptType: InlineScript
    Inline: |
      # Navigate to the scripts directory
      cd /scripts

      # Run Get-TableContents.ps1 to retrieve the table data
      $output = ./Get-TableContents.ps1 -ResourceGroupName "sandpit-01-rg-dev-01" `
                                         -StorageAccountName "sandpitsa" `
                                         -TableName "demo" `
                                         -TableOnly $true

      # Validate if $output has data
      if (-not $output) {
          Write-Error "No data retrieved from Get-TableContents.ps1. Ensure the table exists and has valid data."
          exit 1
      }

      # Process each row in the output
      $output | ForEach-Object {
          # Extract SPN, Project Names, and Project IDs
          $spn = $_.spn
          $projectNames = $_.project_name_to_share_with -split ","
          $projectIds = $_.project_id_to_share_with -split ","

          Write-Host "Processing Service Connection: $spn"

          # Iterate over projects and share the service connection for each project
          for ($i = 0; $i -lt $projectNames.Length; $i++) {
              $projectName = $projectNames[$i]
              $projectId = $projectIds[$i]

              Write-Host "Sharing Service Connection $spn with Project $projectName ($projectId)"

              # Call Share-ServiceConnection.ps1
              ./Share-ServiceConnection.ps1 -PatToken $(patToken) `
                                             -AzOrgURL "https://dev.azure.com/your-org" `
                                             -AzProject "Sandpit.DevTest" `
                                             -AzSCName $spn `
                                             -ProjectNameToShareWith $projectName `
                                             -ProjectIdToShareWith $projectId
          }
      }
    azurePowerShellVersion: LatestVersion


























- task: AzurePowerShell@5
  displayName: 'Share Service Connection'
  inputs:
    azureSubscription: 'sandpit-01-vsts'
    ScriptType: InlineScript
    Inline: |
      # Navigate to the scripts directory
      cd /scripts

      # Run Get-TableContents.ps1 to retrieve the table data
      $output = ./Get-TableContents.ps1 -ResourceGroupName "sandpit-01-rg-dev-01" `
                                         -StorageAccountName "sandpitsa" `
                                         -TableName "demo" `
                                         -TableOnly $true

      # Process each row in the output
      $output | ForEach-Object {
          # Extract SPN, Project Names, and Project IDs
          $spn = $_.spn
          $projectNames = $_.project_name_to_share_with -split ","
          $projectIds = $_.project_id_to_share_with -split ","

          Write-Host "Processing Service Connection: $spn"

          # Iterate over projects and share the service connection for each project
          for ($i = 0; $i -lt $projectNames.Length; $i++) {
              $projectName = $projectNames[$i]
              $projectId = $projectIds[$i]

              Write-Host "Sharing Service Connection $spn with Project $projectName ($projectId)"

              # Call Share-ServiceConnection.ps1
              ./Share-ServiceConnection.ps1 -PatToken $(patToken) `
                                             -AzOrgURL "https://dev.azure.com/your-org" `
                                             -AzProject "Sandpit.DevTest" `
                                             -AzSCName $spn `
                                             -ProjectNameToShareWith $projectName `
                                             -ProjectIdToShareWith $projectId
          }
      }
    azurePowerShellVersion: LatestVersion















#########################################

param (
    [Parameter(Mandatory=$true)]
    [string]$PatToken, # Personal Access Token for Azure DevOps authentication

    [Parameter(Mandatory=$true)]
    [string]$AzOrgURL, # Organization URL (e.g., https://dev.azure.com/your-org/)

    [Parameter(Mandatory=$true)]
    [string]$AzProject, # Source project name where the service connection exists

    [Parameter(Mandatory=$true)]
    [string]$AzSCName, # Name of the service connection to be shared

    [Parameter(Mandatory=$true)]
    [string]$ProjectNameToShareWith, # Target project name

    [Parameter(Mandatory=$true)]
    [string]$ProjectIdToShareWith # Target project ID
)

# Encode PAT for Authorization Header
$base64AuthInfo = [Convert]::ToBase64String([Text.Encoding]::ASCII.GetBytes(":$PatToken"))

# GET ServiceConnection ID
$serviceConnectionEndpoint = "$AzOrgURL/$AzProject/_apis/serviceendpoint/endpoints?endpointNames=$AzSCName&api-version=7.1"
try {
    $OutputSC = Invoke-RestMethod -Uri $serviceConnectionEndpoint -Method GET -Headers @{
        Authorization=("Basic {0}" -f $base64AuthInfo)
    }
} catch {
    Write-Error "Failure getting service connection ID: $($_.Exception.Message)"
    return
}

# Validate and Extract Service Connection ID
if ($OutputSC.value -and $OutputSC.value.Count -gt 0) {
    $serviceConnectionId = $OutputSC.value[0].id
    Write-Host "Found Service Connection ID: $serviceConnectionId"
} else {
    Write-Error "No service connection found with name: $AzSCName"
    return
}

# Prepare Service Connection Share URL
$serviceConnectionShareUrl = "$AzOrgURL/_apis/serviceendpoint/endpoints/$serviceConnectionId/share?api-version=7.1-preview.1"

# Create JSON Body for Sharing Service Connection
$jsonBody = @(
    @{
        id = $ProjectIdToShareWith
        name = $ProjectNameToShareWith
    }
) | ConvertTo-Json -Depth 3 -Compress

# Debug: Log JSON Body
Write-Host "DEBUG: Generated JSON Body for Project $ProjectNameToShareWith:"
Write-Host $jsonBody

Write-Host "Sharing service connection with project: $ProjectNameToShareWith ($ProjectIdToShareWith)"

try {
    $response = Invoke-RestMethod -Uri $serviceConnectionShareUrl -Method POST -ContentType "application/json" -Body $jsonBody -Headers @{
        Authorization=("Basic {0}" -f $base64AuthInfo)
    }
    Write-Host "Successfully shared service connection with project: $ProjectNameToShareWith"
} catch {
    if ($_.Exception.Message -match "already exists") {
        Write-Host "Service connection is already shared with project: $ProjectNameToShareWith"
    } else {
        Write-Error "Failed to share service connection for project $ProjectNameToShareWith: $($_.Exception.Message)"
    }
}












############################################################
###############################task: AzurePowerShell@5
displayName: 'Share Service Connection'
inputs:
  azureSubscription: 'sandpit-01-vsts'
  ScriptType: InlineScript
  Inline: |
    # Navigate to the scripts directory
    cd /scripts

    # Run Get-TableContents.ps1 to retrieve the data table
    $output = ./Get-TableContents.ps1 -ResourceGroupName "sandpit-01-rg-dev-01" `
                                       -StorageAccountName "sandpitsa" `
                                       -TableName "demo" `
                                       -TableOnly $true

    # Process each record from the data table
    $output | ForEach-Object {
        # Extract information for each record
        $spn = $_.spn
        $projectNames = $_.project_name_to_share_with -split ","
        $projectIds = $_.project_id_to_share_with -split ","

        # Log the current SPN being processed
        Write-Output "Processing SPN: $spn"

        # Share service connection for each project
        for ($i = 0; $i -lt $projectNames.Length; $i++) {
            $projectName = $projectNames[$i]
            $projectId = $projectIds[$i]

            Write-Output "Sharing SPN $spn with project $projectName ($projectId)"
            
            ./Share-ServiceConnection.ps1 -PatToken $(patToken) `
                                           -AzProject "Sandpit,DevTest" `
                                           -AzSCName $spn `
                                           -ProjectNameToShareWith $projectName `
                                           -ProjectIdToShareWith $projectId
        }
    }
  azurePowerShellVersion: LatestVersion


param (
    [Parameter(Mandatory=$true)]
    [string]$PatToken, # Personal Access Token for authentication

    [Parameter(Mandatory=$true)]
    [string]$AzProject, # Project where the connection exists

    [Parameter(Mandatory=$true)]
    [string]$AzSCName, # Name of the service connection to be shared

    [Parameter(Mandatory=$true)]
    [string]$ProjectNameToShareWith, # Target project name

    [Parameter(Mandatory=$true)]
    [string]$ProjectIdToShareWith # Target project ID
)

# Function to configure authentication headers
function Get-AuthHeader {
    return @{
        "Authorization" = "Bearer $PatToken"
        "Content-Type" = "application/json"
    }
}

# Log the input parameters
Write-Output "Starting to share service connection: $AzSCName"
Write-Output "From project: $AzProject"
Write-Output "To project: $ProjectNameToShareWith ($ProjectIdToShareWith)"

# Base URL for Azure DevOps REST API
$AzureDevOpsUrl = "https://dev.azure.com/{YourOrganization}/_apis"

# Step 1: Get the service connection ID in the source project
$serviceConnectionUrl = "$AzureDevOpsUrl/projects/$AzProject/serviceendpoint"
$response = Invoke-RestMethod -Uri $serviceConnectionUrl -Headers (Get-AuthHeader) -Method Get

$serviceConnectionId = ($response.value | Where-Object { $_.name -eq $AzSCName }).id

if (-not $serviceConnectionId) {
    Write-Error "Service connection $AzSCName not found in project $AzProject"
    exit 1
}

Write-Output "Found service connection ID: $serviceConnectionId"

# Step 2: Share the service connection with the target project
$shareUrl = "$AzureDevOpsUrl/projects/$AzProject/serviceendpoint/$serviceConnectionId/share"
$shareBody = @{
    targetProjects = @(
        @{
            id = $ProjectIdToShareWith
            name = $ProjectNameToShareWith
        }
    )
} | ConvertTo-Json -Depth 10

$response = Invoke-RestMethod -Uri $shareUrl -Headers (Get-AuthHeader) -Method Post -Body $shareBody

if ($response -ne $null -and $response.status -eq "Success") {
    Write-Output "Successfully shared service connection $AzSCName with project $ProjectNameToShareWith ($ProjectIdToShareWith)"
} else {
    Write-Error "Failed to share service connection $AzSCName with project $ProjectNameToShareWith ($ProjectIdToShareWith)"
    Write-Error "Response: $response"
    exit 1
}


















$jsonBody = @{
    projectReference = @{
        id = $projectId
        name = $projectName
    }
    name = "${AzSCName}-Managed"
} | ConvertTo-Json -Depth 2 -Compress



# Iterate over project names and IDs
for ($i = 0; $i -lt $Projectnamestosharewith.Length; $i++) {
    $projectName = $Projectnamestosharewith[$i]
    $projectId = $projectidstosharewith[$i]

    # Create JSON body dynamically
    $jsonBody = @{
        projectReference = @{
            id = $projectId
            name = $projectName
        }
        name = "$AzSCName-Managed"
    } | ConvertTo-Json -Depth 2 -Compress

    # Debug: Output JSON Body
    Write-Host "DEBUG: Generated JSON Body for Project $projectName:"
    Write-Host $jsonBody

    Write-Host "Sharing service connection with project: $projectName"

    try {
        Invoke-RestMethod -Uri $azureDevOpsServiceConnectionShareUrl -Method PATCH -ContentType "application/json" -Body $jsonBody -Headers @{
            Authorization=("Basic {0}" -f $base64AuthInfo)
        }
        Write-Host "Successfully shared service connection with project: $projectName"
    }
    catch {
        if ($_.Exception.Message -match "already exists") {
            Write-Host "Service connection share configuration already exists for project $projectName"
        } else {
            Write-Error "Failure sharing service connection for project $projectName: $($_.Exception.Message)"
        }
    }
}
































# Iterate over project names and IDs
for ($i = 0; $i -lt $Projectnamestosharewith.Length; $i++) {
    $projectName = $Projectnamestosharewith[$i]
    $projectId = $projectidstosharewith[$i]

    # Create JSON body dynamically
    $jsonBody = @{
        projectReference = @{
            id = $projectId
            name = $projectName
        }
        name = "$AzSCName-Managed"
    } | ConvertTo-Json -Depth 2 -Compress

    # Debug: Output JSON Body
    Write-Host "DEBUG: Generated JSON Body for Project $projectName:"
    Write-Host $jsonBody

    Write-Host "Sharing service connection with project: $projectName"

    try {
        Invoke-RestMethod -Uri $azureDevOpsServiceConnectionShareUrl -Method PATCH -ContentType "application/json" -Body $jsonBody -Headers @{
            Authorization=("Basic {0}" -f $base64AuthInfo)
        }
        Write-Host "Successfully shared service connection with project: $projectName"
    }
    catch {
        if ($_.Exception.Message -match "already exists") {
            Write-Host "Service connection share configuration already exists for project $projectName"
        } else {
            Write-Error "Failure sharing service connection for project $projectName: $($_.Exception.Message)"
        }
    }
}


























# Iterate over project names and IDs
for ($i = 0; $i -lt $Projectnamestosharewith.Length; $i++) {
    $projectName = $Projectnamestosharewith[$i]
    $projectId = $projectidstosharewith[$i]

    # Create JSON body dynamically
    $jsonBody = @{
        projectReference = @{
            id = $projectId
            name = $projectName
        }
        name = "$AzSCName-Managed"
    } | ConvertTo-Json -Depth 2 -Compress

    try {
        Invoke-RestMethod -Uri $azureDevOpsServiceConnectionShareUrl -Method PATCH -ContentType "application/json" -Body $jsonBody -Headers @{
            Authorization=("Basic {0}" -f $base64AuthInfo)
        }
    }
    catch {
        if ($Error[0] -match "already exists") {
            Write-Host "Service connection share configuration already exists for project $projectName"
        } else {
            Write-Error "Failure sharing service connection for project $projectName" $Error[0]
        }
    }
}



# Encode the PAT for authorization
$base64AuthInfo = [Convert]::ToBase64String([Text.Encoding]::ASCII.GetBytes(":$PatToken"))

# GET Service Connection ID
$azureDevOpsServiceConnectionIdCheck = "$AzOrgURL/$AzProject/_apis/serviceendpoint/endpoints?endpointNames=$AzSCName&api-version=7.1-preview.1"
try {
    $outputSC = Invoke-RestMethod -Uri $azureDevOpsServiceConnectionIdCheck -Method GET -ContentType "application/json" -Headers @{Authorization = "Basic $base64AuthInfo"}
} catch {
    Write-Error "Failure getting service connection ID: $_"
    return
}

# Loop through each project to share the service connection
foreach ($AzSharewithProjectName in $AzSharewithProjectNames) {
    # GET Target Project ID
    $azureDevOpsProjectIDUrl = "$AzOrgURL/_apis/projects?api-version=7.1"
    try {
        $outputProjData = Invoke-RestMethod -Uri $azureDevOpsProjectIDUrl -Method GET -ContentType "application/json" -Headers @{Authorization = "Basic $base64AuthInfo"}
        $outputProjID = ($outputProjData.value | Where-Object { $_.name -eq $AzSharewithProjectName }).id
    } catch {
        Write-Error "Failure getting project ID for project '$AzSharewithProjectName': $_"
        continue
    }

    # Share Service Connection
    $azureDevOpsServiceConnectionShareUrl = "$AzOrgURL/_apis/serviceendpoint/endpoints/$($outputSC.value[0].id)?api-version=7.1"
    $jsonBody = @{
        projectReference = @{
            id   = $outputProjID
            name = $AzSharewithProjectName
        }
        name = "$AzSCName-Managed"
    } | ConvertTo-Json -Depth 2

    try {
        Invoke-RestMethod -Uri $azureDevOpsServiceConnectionShareUrl -Method PATCH -ContentType "application/json" -Body $jsonBody -Headers @{Authorization = "Basic $base64AuthInfo"}
        Write-Host "Service connection shared successfully with project '$AzSharewithProjectName'"
    } catch {
        if ($_ -match "already exists") {
            Write-Host "Service connection share configuration already exists for project '$AzSharewithProjectName'"
        } else {
            Write-Error "Failure sharing service connection with project '$AzSharewithProjectName': $_"
        }
    }
}


Remove-TypeData -TypeName "System.Security.AccessControl.ObjectSecurity"
Import-Module Microsoft.PowerShell.Security -Force

# Proxy Address
$proxyAddress = "http://your-proxy-address:port"  # Replace with your proxy server's address

# Proxy Credentials
$proxyUsername = "your-username"  # Replace with your username
$proxyPassword = "your-password"  # Replace with your password
$proxySecureString = ConvertTo-SecureString $proxyPassword -AsPlainText -Force
$proxyCredential = New-Object System.Management.Automation.PSCredential($proxyUsername, $proxySecureString)

# Configure PowerShell to Use the Proxy
[System.Net.WebRequest]::DefaultWebProxy = New-Object System.Net.WebProxy($proxyAddress, $true)
[System.Net.WebRequest]::DefaultWebProxy.Credentials = $proxyCredential


# Define your Azure DevOps organization and Personal Access Token
$organization = "Contoso"  # Replace with your Azure DevOps organization name
$personalAccessToken = "<YourPAT>"  # Replace with your Personal Access Token
$apiVersion = "7.1-preview.4"

# Encode organization for safe URL usage
$encodedOrganization = [System.Uri]::EscapeUriString($organization)

# Construct URL to fetch all projects
$projectsUrl = "https://dev.azure.com/$encodedOrganization/_apis/projects?api-version=$apiVersion"

# Authorization Header
$authHeader = @{
    Authorization = "Basic $([Convert]::ToBase64String([Text.Encoding]::ASCII.GetBytes(":$personalAccessToken")))"
}

# Try to Fetch All Projects
try {
    Write-Output "Fetching all projects for organization: $organization..."
    $projectsResponse = Invoke-RestMethod -Uri $projectsUrl -Method Get -Headers $authHeader

    # Check if there are any projects returned
    if ($projectsResponse.value.Count -eq 0) {
        Write-Output "No projects found in the organization."
    } else {
        Write-Output "Projects found: $($projectsResponse.value.Count)"
        
        # Loop through each project and fetch details
        foreach ($project in $projectsResponse.value) {
            $projectId = $project.id
            $projectName = $project.name

            # Construct URL to fetch project details
            $projectDetailsUrl = "https://dev.azure.com/$encodedOrganization/_apis/projects/$projectId?api-version=$apiVersion"

            try {
                # Fetch detailed project information
                $projectDetails = Invoke-RestMethod -Uri $projectDetailsUrl -Method Get -Headers $authHeader

                # Extract EIM (Project Description)
                $projectDescription = if ($projectDetails.description) {
                    $projectDetails.description
                } else {
                    "No EIM Value Available"
                }

                # Output project details
                Write-Output "Project Name: $projectName"
                Write-Output "Project ID: $projectId"
                Write-Output "EIM: $projectDescription"
                Write-Output "---------------------------"
            } catch {
                # Handle errors fetching project details
                Write-Output "Error fetching details for project: $projectName"
                Write-Output "Error: $($_.Exception.Message)"
            }
        }
    }
} catch {
    # Handle errors fetching all projects
    Write-Output "Error fetching projects: $($_.Exception.Message)"
    Write-Output "Detailed Error: $($_.Exception.InnerException)"
}





- task: PublishPipelineArtifact@1
      displayName: "Publish Terraform Plan"
      inputs:
        targetPath: $(System.DefaultWorkingDirectory)/tfplan
        artifact: tfplan

- task: DownloadPipelineArtifact@2
      displayName: "Download Terraform Plan Artifact"
      inputs:
        artifact: tfplan
        targetPath: $(System.DefaultWorkingDirectory)/tfplan




ccd ./terraform

          # Initialize Terraform with remote backend configuration
          terraform init -no-color -input=false

          # Generate the plan and save it to a file
          terraform plan -var-file="variables.tfvars" -out=tfplan

          # Optional: Output the plan in JSON format for review
          terraform show -json tfplan > tfplan.json

          # Save tfplan to a shared location for the apply step
          mkdir -p $(System.DefaultWorkingDirectory)/tfplan
          cp tfplan $(System.DefaultWorkingDirectory)/tfplan/

cd ./terraform

          # Copy the downloaded tfplan to the current directory
          cp $(System.DefaultWorkingDirectory)/tfplan/tfplan .

          # Apply the plan
          terraform apply -auto-approve tfplan




variables:
  # Build reason
  - template: dev.yaml
  - name: why
    ${{ if eq(variables['Build.Reason'], 'PullRequest') }}:
      value: pr
    ${{ elseif eq(variables['Build.Reason'], 'Manual') }}:
      value: manual
    ${{ elseif eq(variables['Build.Reason'], 'IndividualCI') }}:
      value: indivci
    ${{ elseif eq(variables['Build.Reason'], 'Schedule') }}:
      value: scheduled
    ${{ else }}:
      value: other

  - name: POOL_NAME
    value: "bla-multi-cstmg-01-aks-subscription-prod-v2"
  - name: BuildName
    value: $(Build.DefinitionName)_$(why)_$(Date:yyyyMMdd)


stages:
- stage: PublishArtifact
  displayName: Publish Artifact to Nexus
  jobs:
  - job: PackageAndUpload
    displayName: Package and Upload Artifact
    steps:
    - script: |
        zip -r $(appPackageName) . -x ".git"
      workingDirectory: $(System.DefaultWorkingDirectory)
      displayName: "Package Build"
      enabled: true

    - script: |
        curl -v --user $(nexususername):$(nexuspassword) \
             --upload-file $(appPackageName) \
             $(artifactRepo)/$(appName)/$(appPackageName)
      workingDirectory: $(System.DefaultWorkingDirectory)
      displayName: "Publish Artifact in Nexus"
      enabled: true



parameters:
- name: Region
  default: ''
- name: SourceRepositoryName
  default: ''
- name: TfvarsName
  default: ''
- name: StateName
  default: ''

trigger: none

variables:
  - group: 'IaC_General_UKS'
  - name: SourceRepositoryName
    value: ${{ parameters.SourceRepositoryName }}
    readonly: true
  - name: TfvarsName
    value: ${{ parameters.TfvarsName }}
    readonly: true
  - name: StateName
    value: ${{ parameters.StateName }}
    readonly: true




- task: PowerShell@2
  displayName: 'Terraform validate'
  inputs:
    targetType: 'inline'
    script: |
      Write-Host "##[group]Terraform validate"
      Write-Host "Checks the syntax and validity of Terraform code. It checks for errors in the code, ensuring that the configuration is correctly written."
      Write-Host "Working Directory: $(variables.CustomPath)"
      Write-Host "##[endgroup]"
      
      Write-Host "Run terraform init"
      terraform init -backend=false
      
      Write-Host "Run terraform validate"
      $validationResult = terraform validate -json | ConvertFrom-Json
      
      Write-Host "Check if errors were found"
      if ($validationResult.error_count -gt 0) {
        Write-Error "Errors were found during Terraform validation:"
        $validationResult.diagnostics | ForEach-Object { Write-Error $_.message }
        exit 1
      } else {
        Write-Host "No validation errors found. Proceeding further."
      }
    pwsh: true
    workingDirectory: '$(variables.CustomPath)'





- task: Bash@3
  displayName: 'Install pwsh if not installed'
  script: |
    if [ ! -x "$(command -v pwsh)" ]; then
      echo "Installing PowerShell..."
      sudo apt-get update
      sudo apt-get install -y powershell
    else
      echo "PowerShell is already installed. Continuing to the next step."
    fi
  retryCount: 3



# Run terraform validate
      terraform init -backend=false
      terraform validate -json > validation_result.json
    displayName: 'Run Terraform Validate'

  - script: |
      # Check if errors were found
      if [ -s validation_result.json ]; then
        echo "Errors were found during Terraform validation:"
        cat validation_result.json
        exit 1  # Fail the build
      else
        echo "No errors found. Proceeding further."
      fi
    displayName: 'Check Validation Results'


Write-Host "##[group]TFLint Information"
      Write-Host "This task checks Terraform files using TFLint to ensure best practices and coding standards are followed."
      Write-Host "Working Directory: $(WorkingDirectory)"
      Write-Host "##[endgroup]"




echo -e "\e[1;31mTerraform plan detected changes. Failing the stage.\e[0m"


- task: PowerShell@2
      displayName: Check Terraform plan changes
      inputs:
        targetType: 'inline'
        script: |
          $terraformOutput = Get-Content -Path '$(System.DefaultWorkingDirectory)/terraform-output.txt' -Raw
          if ($terraformOutput -like "*Terraform will perform*") {
            Write-Error "Terraform plan detected changes. Failing the stage."
            exit 1
          }


- powershell: |
    terraform show -json $(System.DefaultWorkingDirectory)/terraform-output.tfplan > $(System.DefaultWorkingDirectory)/terraform-output.txt
  displayName: 'Save Terraform Plan Output'

- task: PowerShell@2
  displayName: 'Check Node.js version'
  inputs:
    targetType: 'inline'
    script: |
      node --version


- task: Bash@3
  displayName: 'Check Terraform plan changes'
  inputs:
    targetType: 'inline'
    script: |
      terraformOutput=$(cat "$(System.DefaultWorkingDirectory)/terraform-output.txt")

      if [[ $terraformOutput == *"Terraform will perform"* ]]; then
        echo "Terraform plan detected changes. Failing the stage."
        exit 1
      fi


- task: Bash@3
      displayName: 'Check Terraform plan changes'
      inputs:
        targetType: 'inline'
        script: |
          terraformOutput=$(cat "$(System.DefaultWorkingDirectory)/terraform-output.txt")

          if [[ $terraformOutput == *"Terraform will perform"* ]]; then
            echo "Terraform plan detected changes. Failing the stage."
            exit 1
          ```
stages:
- stage: BashOnlyStage
  displayName: 'Bash Only Stage'
  jobs:
  - job: RunBashScript
    displayName: 'Run Bash Script'
    pool:
      vmImage: 'ubuntu-latest'
    steps:
    - task: Bash@3
      displayName: 'Run Bash Script'
      inputs:
        targetType: 'inline'
        script: |
          echo "Hello from Bash task!"
____________________________________________

terraformOutput=$(cat "$(System.DefaultWorkingDirectory)/tfplan")

          if [[ $terraformOutput == *"Terraform will perform"* ]]; then
            echo "Terraform plan detected changes. Failing the stage."
            exit 1
          else
            echo "No Terraform plan changes detected."
          fi

terraform show -no-color -json "$(Build.SourcesDirectory)/$(SourceRepositoryName)/tf.tfplan" > $(Build.ArtifactStagingDirectory)/terraform-output.txt


______________________________________________________________________________________________________

- script: |
    terraform show -no-color -json "$(Build.SourcesDirectory)/$(parameters.SourceRepositoryName)/tf.tfplan"
    terraform show -no-color -json "$(Build.SourcesDirectory)/$(parameters.SourceRepositoryName)/tf.tfplan" > $(System.DefaultWorkingDirectory)/terraform-output.txt

    # Check for changes and fail the stage if FailOnChanges is true
    if [[ $(terraform show -no-color -json "$(Build.SourcesDirectory)/$(parameters.SourceRepositoryName)/tf.tfplan") != "null" && $(parameters.FailOnChanges) == true ]]; then
        echo "Terraform plan detected changes. Failing the stage."
        exit 1
    fi
  displayName: 'Check the Terraform plan'
  workingDirectory: '$(Build.SourcesDirectory)/$(parameters.SourceRepositoryName)/env'


# Run Terraform plan and save the output to a file
terraform plan -out=tfplan

# Show the plan in text format and save it to a file
terraform show -no-color tfplan > tfplan.txt

# Check if the "No changes" message is present in the output
if ! grep -q "No changes. Your infrastructure matches the configuration." tfplan.txt; then
    echo "Terraform plan detected changes. Failing the stage."
    exit 1
else
    echo "No changes detected in the Terraform plan. Proceeding with the stage."
fi

if [[ ! $terraformOutput == *"No changes. Your infrastructure matches the configuration."* ]]; then
  echo "Terraform plan detected changes. Failing the stage."
  exit 1
fi
_______________________________________________________________________________________________________________________________________________________

trigger: none

pool:
  vmImage: "ubuntu-latest"

variables:
  - group: 'azure'
  - name: SourceRepositoryName
    value: '$(Build.SourceBranchName)'  # Use the branch name dynamically
    readOnly: true

steps:
- checkout: self
  persistCredentials: true
  clean: true
  displayName: 'Checkout Pull request source branch'

- task: Bash@3
  displayName: 'Check and install Zip'
  script: |
    if [ ! -x "$(command -v zip)" ]; then
      echo "Zip not installed"
      sudo apt-get update
      sudo apt-get install zip -y
    fi
  retryCountOnTaskFailure: 3

- task: Bash@3
  displayName: 'Install pwsh'
  script: |
    sudo apt-get update
    sudo apt-get install -y powershell
  retryCountOnTaskFailure: 3

- task: TerraformInstaller
  displayName: 'Terraform Install'
  inputs:
    terraformVersion: '1.7.1'
    terraformLocation: 'inline'

- task: PowerShell@2
  displayName: 'Terraform fmt check'
  inputs:
    targetType: 'inline'
    script: |
      $output = terraform fmt --recursive
      if (-not $output) {
        Write-Host "terraform fmt found no issues. Moving on."
      } else {
        Write-Error "terraform fmt found issues. Please run terraform fmt locally to format your code and push to your branch."
      }
  pwsh: true
  workingDirectory: '$(Build.SourcesDirectory)/$(variables.SourceRepositoryName)'

- task: PowerShell@2
  displayName: 'Terraform validate'
  inputs:
    targetType: 'inline'
    script: |
      $validateOutput = terraform validate -json
      if ($validateOutput -eq "[]") {
        Write-Host "terraform validate succeeded. Moving on."
      } else {
        Write-Error "terraform validate failed. Please check the following issues: $($validateOutput -join ', ')"
      }
  pwsh: true
  workingDirectory: '$(Build.SourcesDirectory)/$(variables.SourceRepositoryName)'


______________________________________________________________________________________________________________________________________-

trigger: none

pool:
  vmImage: "ubuntu-latest"

variables:
  - group: 'Azure'
  - name: SourceRepositoryName
    value: '$(Build.SourceBranchName)'  # Use the branch name dynamically
    readOnly: true

steps:
- checkout: self
  persistCredentials: true
  clean: true
  displayName: 'Checkout Pull request source branch'

- task: Bash@3
  displayName: 'Check and install Zip'
  script: |
    if [ ! -x "$(command -v zip)" ]; then
      echo "Zip not installed"
      sudo apt-get update
      sudo apt-get install zip -y
    fi
  retryCountOnTaskFailure: 3

- task: Bash@3
  displayName: 'Install pwsh'
  script: |
    sudo apt-get update
    sudo apt-get install -y powershell
  retryCountOnTaskFailure: 3

- task: TerraformInstaller
  displayName: 'Terraform Install'
  inputs:
    terraformVersion: '1.7.1'
    terraformLocation: 'inline'

- task: PowerShell@2
  displayName: 'Terraform fmt check'
  inputs:
    targetType: 'inline'
    script: |
      $output = terraform fmt --recursive
      if (-not $output) {
        Write-Host "terraform fmt found no issues. Continue..."
      } else {
        Write-Error "terraform fmt found issues. Please run terraform fmt locally to format your code and push to your branch."
      }
  pwsh: true
  workingDirectory: '$(Build.SourcesDirectory)/$(variables.SourceRepositoryName)'

- task: PowerShell@2
  displayName: 'TFLint Install'
  inputs:
    targetType: 'inline'
    script: |
      wget https://github.com/terraform-linters/tflint/releases/download/v0.29.0/tflint_linux_amd64.zip
      unzip tflint_linux_amd64.zip
      sudo mv tflint /usr/local/bin/
      rm tflint_linux_amd64.zip
  pwsh: true
  workingDirectory: '$(Build.SourcesDirectory)/$(variables.SourceRepositoryName)'

- task: PowerShell@2
  displayName: 'TFLint check'
  inputs:
    targetType: 'inline'
    script: |
      $tflintOutput = tflint
      if (-not $tflintOutput) {
        Write-Host "TFLint found no issues. Continue..."
      } else {
        Write-Error "TFLint found issues. Please check the following issues: $($tflintOutput -join ', ')"
      }
  pwsh: true
  workingDirectory: '$(Build.SourcesDirectory)/$(variables.SourceRepositoryName)'

