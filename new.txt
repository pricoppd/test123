curl -u :<YourPAT> \
  "https://vssps.dev.azure.com/<YourOrganization>/_apis/graph/groups?api-version=6.0-preview.1"


# Variables
$organization = "YourOrganization"
$pat = "YourPAT"

# Encode PAT for the Authorization header (username is blank)
$base64AuthInfo = [Convert]::ToBase64String([Text.Encoding]::ASCII.GetBytes(":$pat"))
$headers = @{
    Authorization = "Basic $base64AuthInfo"
}

# Define the API URL to list all groups
$url = "https://vssps.dev.azure.com/$organization/_apis/graph/groups?api-version=6.0-preview.1"

# Retrieve groups
$response = Invoke-RestMethod -Uri $url -Headers $headers -Method Get

# Filter for the Endpoint Administrators group
$endpointAdminsGroup = $response.value | Where-Object { $_.displayName -eq "Endpoint Administrators" }

# Output the group descriptor (identity id)
$endpointAdminsGroup.descriptor











# Authentication
$PatToken = "your_personal_access_token"
$Base64AuthInfo = [Convert]::ToBase64String([Text.Encoding]::ASCII.GetBytes(":$PatToken"))
$Headers = @{ Authorization = "Basic $Base64AuthInfo" }

# Define the API URL (delete a service connection)
$Organization = "your_org"
$ProjectId = "your_project_id"
$ServiceConnectionId = "your_service_connection_id"
$ApiVersion = "7.1-preview.1"

$Url = "https://dev.azure.com/$Organization/_apis/serviceendpoint/endpoints/$ServiceConnectionId?api-version=$ApiVersion&project=$ProjectId"

# Send DELETE request
Invoke-RestMethod -Uri $Url -Method Delete -Headers $Headers
#################################################################################################################################################


param (
    [string]$PatToken,
    [string]$AzOrgURL
)

# Encode PAT token for authentication
$Base64AuthInfo = [Convert]::ToBase64String([Text.Encoding]::ASCII.GetBytes(":$PatToken"))
$Headers = @{
    Authorization = "Basic $Base64AuthInfo"
    Accept = "application/json"
}

# Define the path to the Terraform plan output file
$PlanFilePath = "plan.txt"

# Ensure the file exists before proceeding
if (!(Test-Path $PlanFilePath)) {
    Write-Output "Error: Terraform plan file '$PlanFilePath' not found."
    exit 1
}

# Read the plan file content
$PlanContent = Get-Content -Path $PlanFilePath -Raw

# Define regex patterns to extract service connection IDs (SPN)
$DestroyPattern = "(?<=azurerm_serviceendpoint_azurem.service_connection_spn).*?destroyed"
$SpnPattern = "azurerm_serviceendpoint_azurem.service_connection_spn\[""([^""]+)""\]"

# Find service connections marked for deletion
$DestroyMatches = [regex]::Matches($PlanContent, $DestroyPattern, [System.Text.RegularExpressions.RegexOptions]::Singleline)

# Ensure at least one service connection is found
if ($DestroyMatches.Count -eq 0) {
    Write-Output "No service connections marked for deletion found."
    exit 0
}

# Extract the SPN (Service Connection ID)
$SpnList = @()
foreach ($Match in $DestroyMatches) {
    $SpnExtracted = [regex]::Match($Match.Value, $SpnPattern).Groups[1].Value
    if ($SpnExtracted) {
        $SpnList += $SpnExtracted
    }
}

if ($SpnList.Count -eq 0) {
    Write-Output "Error: No valid service connection IDs (SPN) extracted."
    exit 1
}

Write-Output "Found service connections for deletion: $($SpnList -join ', ')"

# Extract project IDs from the Changes to Outputs section
$ProjectIds = @()
$Lines = $PlanContent -split "`n"
$Capture = $false

foreach ($Line in $Lines) {
    if ($Line -match 'project_ids_to_share_with\s*=\s*\[') {
        $Capture = $true
    }

    if ($Capture -and $Line -match '"([^"]+)"') {
        $ProjectIdLine = $Line.Trim()
        $ProjectId = $ProjectIdLine -replace '.*"([^"]+)".*', '$1'
        $ProjectIds += $ProjectId
    }

    if ($Capture -and $Line -match '\]') {
        $Capture = $false
    }
}

# Ensure project IDs were extracted
if ($ProjectIds.Count -eq 0) {
    Write-Output "Error: No valid project IDs found in the Terraform plan."
    exit 1
}

Write-Output "Identified project IDs: $($ProjectIds -join ', ')"

# Remove the shared service connection from each project
foreach ($Spn in $SpnList) {
    foreach ($ProjectId in $ProjectIds) {
        # Construct the Azure DevOps API URL
        $AzureDevOpsServiceConnectionShareUrl = "$AzOrgURL/_apis/serviceendpoint/endpoints/$Spn?api-version=7.1-preview.1&project=$ProjectId"

        Write-Output "Attempting to delete service connection $Spn from project $ProjectId..."

        try {
            $Response = Invoke-RestMethod -Uri $AzureDevOpsServiceConnectionShareUrl -Method Delete -Headers $Headers
            Write-Output "✔ Successfully removed service connection $Spn from project $ProjectId"
        }
        catch {
            Write-Output "❌ Failed to remove service connection $Spn from project $ProjectId"
            Write-Output "Error Details: $_"
        }
    }
}















































































############################################################################################################################################################################################
# Define your Azure DevOps organization and PAT
$organization = "myOrganization"
$pat = "YOUR_PERSONAL_ACCESS_TOKEN"  # Securely store this in production
$base64AuthInfo = [Convert]::ToBase64String([Text.Encoding]::ASCII.GetBytes(":$pat"))
$headers = @{ Authorization = "Basic $base64AuthInfo" }

# Load Terraform plan JSON
$planJson = Get-Content -Raw -Path "plan.json" | ConvertFrom-Json

# Load mapping file that correlates Terraform resource addresses with target projects
$mapping = Get-Content -Raw -Path "mapping.json" | ConvertFrom-Json

# Iterate through each resource change in the plan
foreach ($resourceChange in $planJson.resource_changes) {
    # Check if this is an Azure DevOps service connection and is being deleted
    if ($resourceChange.type -eq "azuredevops_serviceendpoint" -and ($resourceChange.change.actions -contains "delete")) {
        $resourceAddress = $resourceChange.address
        $serviceConnectionId = $resourceChange.change.before.id

        # Lookup the target project from the mapping using the resource address
        $mappingItem = $mapping | Where-Object { $_.resource_address -eq $resourceAddress }
        if (-not $mappingItem) {
            Write-Warning "No mapping found for resource address: $resourceAddress. Skipping unshare."
            continue
        }
        $targetProject = $mappingItem.target_project

        Write-Output "Detected deletion of service connection '$serviceConnectionId' (Resource: $resourceAddress) from project '$targetProject'."

        # Construct the REST API URL for the target project
        $url = "https://dev.azure.com/$organization/$targetProject/_apis/serviceendpoint/endpoints/$serviceConnectionId?api-version=6.0-preview.4"
        Write-Output "Calling DELETE on $url"

        try {
            $response = Invoke-RestMethod -Uri $url -Method DELETE -Headers $headers
            Write-Output "Successfully unshared service connection $serviceConnectionId from project $targetProject."
        }
        catch {
            Write-Error "Error unsharing service connection $serviceConnectionId from project $targetProject: $_"
        }
    }
}

























# Define your Azure DevOps parameters
$organization = "myOrganization"
# If each shared connection is in a different project, you might need to map each resource to its target project.
# For simplicity, we assume all shares are in one project.
$project = "myProject"
$pat = "YOUR_PERSONAL_ACCESS_TOKEN"  # Replace with your PAT
$base64AuthInfo = [Convert]::ToBase64String([Text.Encoding]::ASCII.GetBytes(":$pat"))
$headers = @{ Authorization = "Basic $base64AuthInfo" }

# Load the Terraform plan JSON
$planJson = Get-Content -Raw -Path "plan.json" | ConvertFrom-Json

# Iterate through resource changes
foreach ($resourceChange in $planJson.resource_changes) {
    # Check if this is a service connection and is being deleted
    if ($resourceChange.type -eq "azuredevops_serviceendpoint" -and ($resourceChange.change.actions -contains "delete")) {
        # Extract the service connection ID from the "before" state
        $serviceConnectionId = $resourceChange.change.before.id
        
        # Optional: Add logging or additional logic to determine target projects if needed
        Write-Output "Detected deletion of service connection with ID: $serviceConnectionId"

        # Form the REST API URL (adjust as needed if the shared connection exists in multiple projects)
        $url = "https://dev.azure.com/$organization/$project/_apis/serviceendpoint/endpoints/$serviceConnectionId?api-version=6.0-preview.4"
        
        Write-Output "Calling DELETE on $url"
        try {
            $response = Invoke-RestMethod -Uri $url -Method DELETE -Headers $headers
            Write-Output "Successfully unshared service connection $serviceConnectionId."
        }
        catch {
            Write-Error "Error unsharing service connection $serviceConnectionId: $_"
        }
    }
}












# Define variables
$orgURL = "https://dev.azure.com/YourOrganization"  # Replace with your Azure DevOps organization URL
$AzSharewithProjectName = "YourProjectName"  # Project to share service connections with
$personalAccessToken = "YourPAT"  # Replace with your Azure DevOps Personal Access Token

# Construct the API URL to set permissions at the project level
$azureDevOpsPermissionsUrl = "$orgURL/$AzSharewithProjectName/_apis/securitynamespaces/endpoint/permissions?api-version=7.1"

# Construct the JSON body for setting permissions at the project level
$jsonPermissionsBody = @"
{
    "roleName": "Reader",
    "principalName": "Reader",
    "principalType": "Group"
}
"@

# Encode PAT for Basic Authentication
$base64AuthInfo = [Convert]::ToBase64String([Text.Encoding]::ASCII.GetBytes(":$personalAccessToken"))

try {
    # Make the API request to set permissions at the project level
    Invoke-RestMethod -Uri $azureDevOpsPermissionsUrl `
        -Method POST `
        -ContentType "application/json" `
        -Body $jsonPermissionsBody `
        -Headers @{Authorization=("Basic {0}" -f $base64AuthInfo)}

    Write-Output "Successfully granted Reader permissions to all service connections in project: $AzSharewithProjectName"
} catch {
    Write-Error "Failed to set Reader permissions at the project level: $_"
}


































# Define variables
$orgURL = "https://dev.azure.com/YourOrganization"  # Replace with your Azure DevOps organization URL
$AzSharewithProjectName = "YourProjectName"  # Replace with the target project name
$serviceConnectionId = "YourServiceConnectionID"  # Replace with the service connection ID
$personalAccessToken = "YourPAT"  # Replace with your Azure DevOps Personal Access Token

# Construct the permissions API URL
$azureDevOpsPermissionsUrl = "$orgURL/$AzSharewithProjectName/_apis/securitynamespaces/endpoint/$serviceConnectionId/permissions?api-version=7.1"

# Construct the JSON body for setting permissions
$jsonPermissionsBody = @"
{
    "roleName": "Reader",
    "principalName": "Reader",
    "principalType": "Group"
}
"@

# Encode PAT for Basic Authentication
$base64AuthInfo = [Convert]::ToBase64String([Text.Encoding]::ASCII.GetBytes(":$personalAccessToken"))

try {
    # Make the API request to set permissions
    $response = Invoke-RestMethod -Uri $azureDevOpsPermissionsUrl `
        -Method POST `
        -ContentType "application/json" `
        -Body $jsonPermissionsBody `
        -Headers @{Authorization=("Basic {0}" -f $base64AuthInfo)}

    Write-Output "Successfully set Reader permissions on the shared service connection."
} catch {
    Write-Error "Failure setting Reader permissions on the shared service connection: $_"
}



























stages:
  - stage: Deploy
    jobs:
      - job: CopyArtifact
        pool:
          vmImage: 'ubuntu-latest'

        steps:
          # Step 1: Download the artifact "tfoutput"
          - task: DownloadPipelineArtifact@2
            inputs:
              artifact: 'tfoutput'  # Name of the artifact
              path: '$(Pipeline.Workspace)/tfoutput'  # Destination folder

          # Step 2: Copy the artifact into the existing "terraform" folder
          - script: |
              $SourcePath = "$(Pipeline.Workspace)/tfoutput/*"  # Path to files inside tfoutput
              $DestinationPath = "$(Build.SourcesDirectory)/terraform"  # Path to existing terraform folder

              # Ensure the destination folder exists
              if (!(Test-Path $DestinationPath)) {
                Write-Host "Creating destination folder: $DestinationPath"
                New-Item -Path $DestinationPath -ItemType Directory
              }

              # Copy the contents of tfoutput into terraform
              Copy-Item -Path $SourcePath -Destination $DestinationPath -Recurse -Force

              Write-Host "tfoutput artifact copied into the existing terraform folder: $DestinationPath"
            displayName: 'Copy tfoutput Artifact into terraform Folder'
            shell: pwsh



- script: |
    $FilePath = "$(Build.SourcesDirectory)/main.tfvars"

    # Read file using a supported method
    $Content = [System.IO.File]::ReadAllText($FilePath)

    # Output the content for debugging
    Write-Host "TFVARS Content:`n$Content"
  displayName: 'Read main.tfvars in Azure DevOps'
  shell: pwsh




- script: |
    $FilePath = "$(Build.SourcesDirectory)/main.tfvars"

    # Read file efficiently using StreamReader
    $Reader = New-Object System.IO.StreamReader($FilePath)

    while (($line = $Reader.ReadLine()) -ne $null) {
        Write-Host "Line: $line"
    }

    $Reader.Close()
  displayName: 'Read main.tfvars Efficiently'
  shell: pwsh



- script: |
    $FilePath = "$(Build.SourcesDirectory)/main.tfvars"  # File location
    $Content = [System.IO.File]::ReadAllText($FilePath)

    # Output content for debugging (optional)
    Write-Host "TFVARS Content: `n$Content"
  displayName: 'Read main.tfvars File'
  shell: pwsh




# Define file path
$JsonFilePath = "C:\Path\To\output.json"  # Change this to your actual JSON file path

# Read and parse JSON file
$JsonContent = Get-Content $JsonFilePath | ConvertFrom-Json

# Extract 'spn_names' values
$SpnNames = $JsonContent.spn_names.value

# Convert PowerShell array to Terraform format ["value1", "value2"]
$SpnNamesTfList = "[" + ($SpnNames -join '","') + "]"

# Output formatted value to Azure DevOps pipeline logs
Write-Host "SPN_NAMES_TF_LIST=`"$SpnNamesTfList`""

# Set as Azure DevOps pipeline variable
Write-Host "##vso[task.setvariable variable=spnNamesTfList]$SpnNamesTfList"


- script: |
    $tfOutput = terraform output -json | ConvertFrom-Json
    $spnNames = $tfOutput.spn_names.value

    # Convert PowerShell array to Terraform format ["value1", "value2"]
    $spnNamesTfList = "[" + ($spnNames -join '","') + "]"

    # Output the formatted value to Azure DevOps pipeline logs
    Write-Host "SPN_NAMES_TF_LIST=`"$spnNamesTfList`""

    # Set as an Azure DevOps pipeline variable
    Write-Host "##vso[task.setvariable variable=spnNamesTfList]$spnNamesTfList"
  displayName: 'Extract Terraform Outputs Using PowerShell'
  shell: pwsh




stages:
  - stage: Terraform
    jobs:
      - job: ApplyTerraform
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - script: |
              terraform init
              terraform apply -auto-approve
            displayName: 'Terraform Init & Apply'

          - script: |
              TF_OUTPUT=$(terraform output -json)
              SPN_NAMES=$(echo $TF_OUTPUT | jq -c '.spn_names.value')

              # Convert array to Terraform format ["value1", "value2"]
              SPN_NAMES_TF_LIST=$(echo $SPN_NAMES | jq -c '. | map("\"" + . + "\"") | join(",")')
              SPN_NAMES_TF_LIST="[$SPN_NAMES_TF_LIST]"

              echo "##vso[task.setvariable variable=spnNamesTfList]$SPN_NAMES_TF_LIST"
            displayName: 'Extract Terraform Outputs'
            shell: bash

          - script: |
              terraform apply -auto-approve -var="spn_names=$(spnNamesTfList)"
            displayName: 'Run Terraform with SPN List'





# Define variables
$resourceGroupName = "<YourResourceGroup>"   # Replace with your Resource Group name
$storageAccountName = "<YourStorageAccount>" # Replace with your Storage Account name
$tableName = "<YourTableName>"               # Replace with your Table name
$csvFilePath = "C:\Temp\TableData.csv"       # Replace with the desired output CSV file path

# Authenticate to Azure
Connect-AzAccount

# Get the storage account context
$storageContext = (Get-AzStorageAccount -ResourceGroupName $resourceGroupName -Name $storageAccountName).Context

# Retrieve table rows
$tableRows = Get-AzTableRow -Table $tableName -StorageContext $storageContext

# Export the table rows to CSV
$tableRows | Export-Csv -Path $csvFilePath -NoTypeInformation -Encoding UTF8

Write-Output "Table data exported successfully to $csvFilePath"









# Define variables
$resourceGroupName = "<YourResourceGroup>"   # Replace with your resource group name
$storageAccountName = "<YourStorageAccount>" # Replace with your storage account name
$tableName = "<YourTableName>"               # Replace with your table name

# Get the storage account context
$storageContext = (Get-AzStorageAccount -ResourceGroupName $resourceGroupName -Name $storageAccountName).Context

# Query the table content
$tableContent = Get-AzTableRow -TableName $tableName -Context $storageContext

# Output the results
$tableContent | ForEach-Object {
    Write-Output "PartitionKey: $($_.PartitionKey), RowKey: $($_.RowKey)"
    $_
}




# Variables
$resourceGroupName = "YourResourceGroupName"
$storageAccountName = "YourStorageAccountName"
$tableName = "YourTableName"
$outputFile = "C:\Path\To\ExportedTable.csv"

# Authenticate and set storage context
Connect-AzAccount
$storageAccountKey = (Get-AzStorageAccountKey -ResourceGroupName $resourceGroupName -Name $storageAccountName).Value[0]
$storageContext = New-AzStorageContext -StorageAccountName $storageAccountName -StorageAccountKey $storageAccountKey

# Get Table Data
$tableData = Get-AzTableRow -TableName $tableName -Context $storageContext

# Export to CSV
$tableData | Export-Csv -Path $outputFile -NoTypeInformation -Encoding UTF8

Write-Host "Table data exported to $outputFile"




# Attempt to share the service connection
Write-Host "Checking service connection sharing for: ${AzSCName} with project: ${ProjectNameToShareWith} (${ProjectIdToShareWith})"

try {
    # Check if Service Connection is already shared
    Write-Host "DEBUG: Fetching details of the service connection."
    $checkAuthorizedProjectsUrl = "$AzOrgURL/_apis/serviceendpoint/endpoints/$serviceConnectionId?api-version=7.1"
    $serviceConnectionDetails = Invoke-RestMethod -Uri $checkAuthorizedProjectsUrl -Method GET -Headers @{
        Authorization=("Basic {0}" -f $base64AuthInfo)
    } -ErrorAction Stop

    # Determine if the target project is already authorized
    if ($serviceConnectionDetails.authorization.authorizedProjects.id -contains $ProjectIdToShareWith) {
        Write-Host "Service connection ${AzSCName} is already shared with project ${ProjectNameToShareWith}. Skipping."
        return
    }

    # If not already shared, proceed with sharing
    Write-Host "Service connection ${AzSCName} is not shared with project ${ProjectNameToShareWith}. Attempting to share."

    # Prepare POST request for creating the service connection sharing
    $postUrl = "$AzOrgURL/$AzProject/_apis/serviceendpoint/endpoints/$serviceConnectionId/share?api-version=7.1-preview.1"
    $postBody = @"
    [
        {
            "projectReference": {
                "id": "$ProjectIdToShareWith",
                "name": "$ProjectNameToShareWith"
            },
            "name": "$AzSCName"
        }
    ]
    "@

    Write-Host "DEBUG: Sending POST request to create service connection sharing."
    $response = Invoke-RestMethod -Uri $postUrl -Method POST -ContentType "application/json" -Body $postBody -Headers @{
        Authorization=("Basic {0}" -f $base64AuthInfo)
    } -ErrorAction Stop
    Write-Host "Successfully shared service connection ${AzSCName} with project ${ProjectNameToShareWith}."
} catch {
    Write-Error "Failed to process service connection sharing for ${AzSCName} with project ${ProjectNameToShareWith}."
    Write-Error "Response: $($_.Exception.Response | ConvertTo-Json -Depth 3)"
    Write-Error "Error Details: $($_.Exception | ConvertTo-Json -Depth 3)"
}

















































param (
    [Parameter(Mandatory=$true)]
    [string]$PatToken, # Personal Access Token for Azure DevOps authentication

    [Parameter(Mandatory=$true)]
    [string]$AzOrgURL, # Organization URL (e.g., https://dev.azure.com/your-org/)

    [Parameter(Mandatory=$true)]
    [string]$AzProject, # Source project name where the service connection exists

    [Parameter(Mandatory=$true)]
    [string]$AzSCName, # Name of the service connection to be shared

    [Parameter(Mandatory=$true)]
    [string]$ProjectNameToShareWith, # Target project name

    [Parameter(Mandatory=$true)]
    [string]$ProjectIdToShareWith # Target project ID
)

# Encode PAT for Authorization Header
$base64AuthInfo = [Convert]::ToBase64String([Text.Encoding]::ASCII.GetBytes(":$PatToken"))

# GET ServiceConnection ID
$serviceConnectionEndpoint = "$AzOrgURL/$AzProject/_apis/serviceendpoint/endpoints?endpointNames=$AzSCName&api-version=7.1"
try {
    Write-Host "DEBUG: Fetching service connection ID from URL: $serviceConnectionEndpoint"
    $OutputSC = Invoke-RestMethod -Uri $serviceConnectionEndpoint -Method GET -Headers @{
        Authorization=("Basic {0}" -f $base64AuthInfo)
    } -ErrorAction Stop
} catch {
    Write-Error "Failure getting service connection ID: $($_.Exception.Message)"
    return
}

# Validate and Extract Service Connection ID
if ($OutputSC.value -and $OutputSC.value.Count -gt 0) {
    $serviceConnectionId = $OutputSC.value[0].id
    Write-Host "DEBUG: Found Service Connection ID: ${serviceConnectionId}"
} else {
    Write-Error "No service connection found with name: ${AzSCName}"
    return
}

# Check Current Authorized Projects
$checkAuthorizedProjectsUrl = "$AzOrgURL/_apis/serviceendpoint/endpoints/$serviceConnectionId?api-version=7.1-preview.1"
try {
    Write-Host "DEBUG: Fetching authorized projects for Service Connection ID: ${serviceConnectionId}"
    $currentServiceConnectionDetails = Invoke-RestMethod -Uri $checkAuthorizedProjectsUrl -Method GET -Headers @{
        Authorization=("Basic {0}" -f $base64AuthInfo)
    } -ErrorAction Stop

    # Check if ProjectIdToShareWith is already authorized
    $isAlreadyShared = $false
    if ($currentServiceConnectionDetails.authorization -and $currentServiceConnectionDetails.authorization.authorizedProjects) {
        foreach ($project in $currentServiceConnectionDetails.authorization.authorizedProjects) {
            if ($project.id -eq $ProjectIdToShareWith) {
                $isAlreadyShared = $true
                break
            }
        }
    }

    if ($isAlreadyShared) {
        Write-Host "Service connection ${AzSCName} is already shared with project ${ProjectNameToShareWith} (${ProjectIdToShareWith}). Skipping."
        return
    }

} catch {
    Write-Error "Failed to check authorized projects for Service Connection ID: ${serviceConnectionId}. Error: $($_.Exception.Message)"
    return
}

# Prepare Service Connection Share URL
$serviceConnectionShareUrl = "$AzOrgURL/_apis/serviceendpoint/endpoints/$serviceConnectionId/share?api-version=7.1-preview.1"
Write-Host "DEBUG: Service Connection Share URL: ${serviceConnectionShareUrl}"

# Create JSON Body for Sharing Service Connection
$jsonBody = @"
[
    {
        "projectReference": {
            "id": "$ProjectIdToShareWith",
            "name": "$ProjectNameToShareWith"
        },
        "name": "$AzSCName"
    }
]
"@

# Debug: Log JSON Body
Write-Host "DEBUG: JSON Body for Sharing Service Connection:"
Write-Host $jsonBody

# Attempt to share the service connection
Write-Host "Sharing service connection: ${AzSCName} with project: ${ProjectNameToShareWith} (${ProjectIdToShareWith})"

try {
    $response = Invoke-RestMethod -Uri $serviceConnectionShareUrl -Method POST -ContentType "application/json" -Body $jsonBody -Headers @{
        Authorization=("Basic {0}" -f $base64AuthInfo)
    } -ErrorAction Stop
    Write-Host "Successfully shared service connection ${AzSCName} with project ${ProjectNameToShareWith}"
} catch {
    Write-Error "Failed to share service connection ${AzSCName} with project ${ProjectNameToShareWith}."
    Write-Error "Response: $($_.Exception.Response | ConvertTo-Json -Depth 3)"
    Write-Error "Error Details: $($_.Exception | ConvertTo-Json -Depth 3)"
}

























param (
    [Parameter(Mandatory=$true)]
    [string]$PatToken, # Personal Access Token for Azure DevOps authentication

    [Parameter(Mandatory=$true)]
    [string]$AzOrgURL, # Organization URL (e.g., https://dev.azure.com/your-org/)

    [Parameter(Mandatory=$true)]
    [string]$AzProject, # Source project name where the service connection exists

    [Parameter(Mandatory=$true)]
    [string]$AzSCName, # Name of the service connection to be shared

    [Parameter(Mandatory=$true)]
    [string]$ProjectNameToShareWith, # Target project name

    [Parameter(Mandatory=$true)]
    [string]$ProjectIdToShareWith # Target project ID
)

# Encode PAT for Authorization Header
$base64AuthInfo = [Convert]::ToBase64String([Text.Encoding]::ASCII.GetBytes(":$PatToken"))

# GET ServiceConnection ID
$serviceConnectionEndpoint = "$AzOrgURL/$AzProject/_apis/serviceendpoint/endpoints?endpointNames=$AzSCName&api-version=7.1"
try {
    Write-Host "DEBUG: Fetching service connection ID from URL: $serviceConnectionEndpoint"
    $OutputSC = Invoke-RestMethod -Uri $serviceConnectionEndpoint -Method GET -Headers @{
        Authorization=("Basic {0}" -f $base64AuthInfo)
    } -ErrorAction Stop
} catch {
    Write-Error "Failure getting service connection ID: $($_.Exception.Message)"
    return
}

# Validate and Extract Service Connection ID
if ($OutputSC.value -and $OutputSC.value.Count -gt 0) {
    $serviceConnectionId = $OutputSC.value[0].id
    Write-Host "DEBUG: Found Service Connection ID: ${serviceConnectionId}"
} else {
    Write-Error "No service connection found with name: ${AzSCName}"
    return
}

# Prepare Service Connection Share URL
$serviceConnectionShareUrl = "$AzOrgURL/_apis/serviceendpoint/endpoints/$serviceConnectionId/share?api-version=7.1-preview.1"
Write-Host "DEBUG: Service Connection Share URL: ${serviceConnectionShareUrl}"

# Create JSON Body for Sharing Service Connection
$jsonBody = @"
[
    {
        "projectReference": {
            "id": "$ProjectIdToShareWith",
            "name": "$ProjectNameToShareWith"
        },
        "name": "$AzSCName"
    }
]
"@

# Debug: Log JSON Body
Write-Host "DEBUG: JSON Body for Sharing Service Connection:"
Write-Host $jsonBody

# Attempt to share the service connection
Write-Host "Sharing service connection: ${AzSCName} with project: ${ProjectNameToShareWith} (${ProjectIdToShareWith})"

try {
    $response = Invoke-RestMethod -Uri $serviceConnectionShareUrl -Method POST -ContentType "application/json" -Body $jsonBody -Headers @{
        Authorization=("Basic {0}" -f $base64AuthInfo)
    } -ErrorAction Stop
    Write-Host "Successfully shared service connection ${AzSCName} with project ${ProjectNameToShareWith}"
} catch {
    Write-Error "Failed to share service connection ${AzSCName} with project ${ProjectNameToShareWith}."
    Write-Error "Response: $($_.Exception.Response | ConvertTo-Json -Depth 3)"
    Write-Error "Error Details: $($_.Exception | ConvertTo-Json -Depth 3)"
}




















































param (
    [Parameter(Mandatory=$true)]
    [string]$PatToken, # Personal Access Token for Azure DevOps authentication

    [Parameter(Mandatory=$true)]
    [string]$AzOrgURL, # Organization URL (e.g., https://dev.azure.com/your-org/)

    [Parameter(Mandatory=$true)]
    [string]$AzProject, # Source project name where the service connection exists

    [Parameter(Mandatory=$true)]
    [string]$AzSCName, # Name of the service connection to be shared

    [Parameter(Mandatory=$true)]
    [string]$ProjectNameToShareWith, # Target project name

    [Parameter(Mandatory=$true)]
    [string]$ProjectIdToShareWith # Target project ID
)

# Encode PAT for Authorization Header
$base64AuthInfo = [Convert]::ToBase64String([Text.Encoding]::ASCII.GetBytes(":$PatToken"))

# GET ServiceConnection ID
$serviceConnectionEndpoint = "$AzOrgURL/$AzProject/_apis/serviceendpoint/endpoints?endpointNames=$AzSCName&api-version=7.1"
try {
    Write-Host "DEBUG: Fetching service connection ID from URL: $serviceConnectionEndpoint"
    $OutputSC = Invoke-RestMethod -Uri $serviceConnectionEndpoint -Method GET -Headers @{
        Authorization=("Basic {0}" -f $base64AuthInfo)
    } -ErrorAction Stop
} catch {
    Write-Error "Failure getting service connection ID: $($_.Exception.Message)"
    return
}

# Validate and Extract Service Connection ID
if ($OutputSC.value -and $OutputSC.value.Count -gt 0) {
    $serviceConnectionId = $OutputSC.value[0].id
    Write-Host "DEBUG: Found Service Connection ID: ${serviceConnectionId}"
} else {
    Write-Error "No service connection found with name: ${AzSCName}"
    return
}

# Prepare Service Connection Share URL
$serviceConnectionShareUrl = "$AzOrgURL/_apis/serviceendpoint/endpoints/$serviceConnectionId/share?api-version=7.1-preview.1"
Write-Host "DEBUG: Service Connection Share URL: ${serviceConnectionShareUrl}"

# Create JSON Body for Sharing Service Connection
$jsonBody = @"
[
    {
        "projectReference": {
            "id": "$ProjectIdToShareWith",
            "name": "$ProjectNameToShareWith"
        },
        "name": "$AzSCName"
    }
]
"@

# Debug: Log JSON Body
Write-Host "DEBUG: JSON Body for Sharing Service Connection:"
Write-Host $jsonBody

# Attempt to share the service connection
Write-Host "Sharing service connection: ${AzSCName} with project: ${ProjectNameToShareWith} (${ProjectIdToShareWith})"

try {
    $response = Invoke-RestMethod -Uri $serviceConnectionShareUrl -Method POST -ContentType "application/json" -Body $jsonBody -Headers @{
        Authorization=("Basic {0}" -f $base64AuthInfo)
    } -ErrorAction Stop
    Write-Host "Successfully shared service connection ${AzSCName} with project ${ProjectNameToShareWith}"
} catch {
    Write-Error "Failed to share service connection ${AzSCName} with project ${ProjectNameToShareWith}."
    Write-Error "Response: $($_.Exception.Response | ConvertTo-Json -Depth 3)"
    Write-Error "Error Details: $($_.Exception | ConvertTo-Json -Depth 3)"
}






































# Attempt to update the service connection
Write-Host "Authorizing project: ${ProjectIdToShareWith} for service connection: ${serviceConnectionId}"

try {
    $response = Invoke-RestMethod -Uri $serviceConnectionUpdateUrl -Method PATCH -ContentType "application/json" -Body $jsonBody -Headers @{
        Authorization=("Basic {0}" -f $base64AuthInfo)
    } -ErrorAction Stop
    Write-Host "Successfully authorized project ${ProjectIdToShareWith} for service connection ${serviceConnectionId}"
} catch {
    Write-Error "Failed to authorize project ${ProjectIdToShareWith} for service connection ${serviceConnectionId}."
    Write-Error "Response: $($_.Exception.Response | ConvertTo-Json -Depth 3)"
    Write-Error "Error Details: $($_.Exception | ConvertTo-Json -Depth 3)"
}




























param (
    [Parameter(Mandatory=$true)]
    [string]$PatToken, # Personal Access Token for Azure DevOps authentication

    [Parameter(Mandatory=$true)]
    [string]$AzOrgURL, # Organization URL (e.g., https://dev.azure.com/your-org/)

    [Parameter(Mandatory=$true)]
    [string]$AzProject, # Source project name where the service connection exists

    [Parameter(Mandatory=$true)]
    [string]$AzSCName, # Name of the service connection to be shared

    [Parameter(Mandatory=$true)]
    [string]$ProjectNameToShareWith, # Target project name

    [Parameter(Mandatory=$true)]
    [string]$ProjectIdToShareWith # Target project ID
)

# Encode PAT for Authorization Header
$base64AuthInfo = [Convert]::ToBase64String([Text.Encoding]::ASCII.GetBytes(":$PatToken"))

# GET ServiceConnection ID
$serviceConnectionEndpoint = "$AzOrgURL/$AzProject/_apis/serviceendpoint/endpoints?endpointNames=$AzSCName&api-version=7.1"
try {
    Write-Host "DEBUG: Fetching service connection ID from URL: $serviceConnectionEndpoint"
    $OutputSC = Invoke-RestMethod -Uri $serviceConnectionEndpoint -Method GET -Headers @{
        Authorization=("Basic {0}" -f $base64AuthInfo)
    } -ErrorAction Stop
} catch {
    Write-Error "Failure getting service connection ID: $($_.Exception.Message)"
    return
}

# Validate and Extract Service Connection ID
if ($OutputSC.value -and $OutputSC.value.Count -gt 0) {
    $serviceConnectionId = $OutputSC.value[0].id
    Write-Host "DEBUG: Found Service Connection ID: ${serviceConnectionId}"
} else {
    Write-Error "No service connection found with name: ${AzSCName}"
    return
}

# Prepare Service Connection Share URL
$serviceConnectionShareUrl = "$AzOrgURL/_apis/serviceendpoint/endpoints/$serviceConnectionId/share?api-version=7.1-preview.1"
Write-Host "DEBUG: Service Connection Share URL: ${serviceConnectionShareUrl}"

# Create JSON Body for Sharing Service Connection
$jsonBody = @{
    projectReference = @{
        id = $ProjectIdToShareWith
        name = $ProjectNameToShareWith
    }
} | ConvertTo-Json -Depth 3 -Compress

# Debug: Log JSON Body
Write-Host "DEBUG: Generated JSON Body for Project ${ProjectNameToShareWith}:"
Write-Host $jsonBody

# Attempt to share the service connection
Write-Host "Sharing service connection with project: ${ProjectNameToShareWith} (${ProjectIdToShareWith})"

try {
    $response = Invoke-RestMethod -Uri $serviceConnectionShareUrl -Method POST -ContentType "application/json" -Body $jsonBody -Headers @{
        Authorization=("Basic {0}" -f $base64AuthInfo)
    } -ErrorAction Stop
    Write-Host "Successfully shared service connection with project: ${ProjectNameToShareWith}"
} catch {
    Write-Error "Failed to share service connection for project ${ProjectNameToShareWith}."
    Write-Error "Response: $($_.Exception.Response | ConvertTo-Json -Depth 3)"
    Write-Error "Error Details: $($_.Exception | ConvertTo-Json -Depth 3)"
}


######################################################

















param (
    [Parameter(Mandatory=$true)]
    [string]$PatToken, # Personal Access Token for Azure DevOps authentication

    [Parameter(Mandatory=$true)]
    [string]$AzOrgURL, # Organization URL (e.g., https://dev.azure.com/your-org/)

    [Parameter(Mandatory=$true)]
    [string]$AzProject, # Source project name where the service connection exists

    [Parameter(Mandatory=$true)]
    [string]$AzSCName, # Name of the service connection to be shared

    [Parameter(Mandatory=$true)]
    [string]$ProjectNameToShareWith, # Target project name

    [Parameter(Mandatory=$true)]
    [string]$ProjectIdToShareWith # Target project ID
)

# Encode PAT for Authorization Header
$base64AuthInfo = [Convert]::ToBase64String([Text.Encoding]::ASCII.GetBytes(":$PatToken"))

# GET ServiceConnection ID
$serviceConnectionEndpoint = "$AzOrgURL/$AzProject/_apis/serviceendpoint/endpoints?endpointNames=$AzSCName&api-version=7.1"
try {
    $OutputSC = Invoke-RestMethod -Uri $serviceConnectionEndpoint -Method GET -Headers @{
        Authorization=("Basic {0}" -f $base64AuthInfo)
    } -ErrorAction Stop
} catch {
    Write-Error "Failure getting service connection ID: $($_.Exception.Message)"
    return
}

# Validate and Extract Service Connection ID
if ($OutputSC.value -and $OutputSC.value.Count -gt 0) {
    $serviceConnectionId = $OutputSC.value[0].id
    Write-Host "Found Service Connection ID: ${serviceConnectionId}"
} else {
    Write-Error "No service connection found with name: ${AzSCName}"
    return
}

# Prepare Service Connection Share URL
$serviceConnectionShareUrl = "$AzOrgURL/_apis/serviceendpoint/endpoints/$serviceConnectionId/share?api-version=7.1-preview.1"

# Create JSON Body for Sharing Service Connection
$jsonBody = @{
    projectReference = @{
        id = $ProjectIdToShareWith
        name = $ProjectNameToShareWith
    }
} | ConvertTo-Json -Depth 3 -Compress

# Debug: Log JSON Body
Write-Host "DEBUG: Generated JSON Body for Project ${ProjectNameToShareWith}:"
Write-Host $jsonBody

Write-Host "Sharing service connection with project: ${ProjectNameToShareWith} (${ProjectIdToShareWith})"

try {
    $response = Invoke-RestMethod -Uri $serviceConnectionShareUrl -Method POST -ContentType "application/json" -Body $jsonBody -Headers @{
        Authorization=("Basic {0}" -f $base64AuthInfo)
    } -ErrorAction Stop
    Write-Host "Successfully shared service connection with project: ${ProjectNameToShareWith}"
} catch {
    if ($_.Exception.Message -match "already exists") {
        Write-Host "Service connection is already shared with project: ${ProjectNameToShareWith}"
    } else {
        Write-Error "Failed to share service connection for project ${ProjectNameToShareWith}. Error: $($_.Exception.Message)"
    }
}




































- task: AzurePowerShell@5
  displayName: 'Share Service Connection'
  inputs:
    azureSubscription: 'sandpit-01-vsts'
    ScriptType: InlineScript
    Inline: |
      # Navigate to the scripts directory
      cd /scripts

      # Run Get-TableContents.ps1 to retrieve the table data
      $output = ./Get-TableContents.ps1 -ResourceGroupName "sandpit-01-rg-dev-01" `
                                         -StorageAccountName "sandpitsa" `
                                         -TableName "demo" `
                                         -TableOnly $true

      # Validate if $output has data
      if (-not $output) {
          Write-Error "No data retrieved from Get-TableContents.ps1. Ensure the table exists and has valid data."
          exit 1
      }

      # Validate if $output is iterable
      if (-not ($output -is [System.Collections.IEnumerable])) {
          Write-Error "Output is not iterable. Ensure the script returns an array of objects."
          exit 1
      }

      # Debug: Log the structure of $output
      Write-Host "DEBUG: Output from Get-TableContents.ps1:"
      Write-Host ($output | ConvertTo-Json -Depth 3)

      # Iterate through each row in the output
      foreach ($row in $output) {
          # Extract SPN, Project Names, and Project IDs
          $spn = $row.spn
          $projectNames = $row.project_name_to_share_with -split ","
          $projectIds = $row.project_id_to_share_with -split ","

          Write-Host "Processing Service Connection: $spn"

          # Skip if project names or IDs are null or empty
          if (-not $row.project_name_to_share_with -or -not $row.project_id_to_share_with) {
              Write-Host "Skipping SPN: $spn due to missing project names or IDs."
              continue
          }

          # Ensure project names and IDs match in length
          if ($projectNames.Length -ne $projectIds.Length) {
              Write-Error "Mismatch between project names and IDs for SPN: $spn"
              continue
          }

          # Process each project for the current SPN
          for ($i = 0; $i -lt $projectNames.Length; $i++) {
              $projectName = $projectNames[$i]
              $projectId = $projectIds[$i]

              # Escape special characters for logging
              Write-Host ("Sharing Service Connection {0} with Project {1} ({2})" -f $spn, $projectName, $projectId)

              # Call Share-ServiceConnection.ps1
              try {
                  ./Share-ServiceConnection.ps1 -PatToken $(patToken) `
                                                 -AzOrgURL "https://dev.azure.com/your-org" `
                                                 -AzProject "Sandpit.DevTest" `
                                                 -AzSCName $spn `
                                                 -ProjectNameToShareWith $projectName `
                                                 -ProjectIdToShareWith $projectId
                  Write-Host "Successfully shared service connection $spn with Project $projectName"
              } catch {
                  Write-Error ("Failed to share service connection {0} with Project {1}. Error: {2}" -f $spn, $projectName, $_.Exception.Message)
              }
          }
      }
    azurePowerShellVersion: LatestVersion

































































- task: AzurePowerShell@5
  displayName: 'Share Service Connection'
  inputs:
    azureSubscription: 'sandpit-01-vsts'
    ScriptType: InlineScript
    Inline: |
      # Navigate to the scripts directory
      cd /scripts

      # Run Get-TableContents.ps1 to retrieve the table data
      $output = ./Get-TableContents.ps1 -ResourceGroupName "sandpit-01-rg-dev-01" `
                                         -StorageAccountName "sandpitsa" `
                                         -TableName "demo" `
                                         -TableOnly $true

      # Validate if $output has data
      if (-not $output) {
          Write-Error "No data retrieved from Get-TableContents.ps1. Ensure the table exists and has valid data."
          exit 1
      }

      # Validate if $output is iterable
      if (-not ($output -is [System.Collections.IEnumerable])) {
          Write-Error "Output is not iterable. Ensure the script returns an array of objects."
          exit 1
      }

      # Debug: Log the structure of $output
      Write-Host "DEBUG: Output from Get-TableContents.ps1:"
      Write-Host ($output | ConvertTo-Json -Depth 3)

      # Iterate through each row in the output
      foreach ($row in $output) {
          # Extract SPN, Project Names, and Project IDs
          $spn = $row.spn
          $projectNames = $row.project_name_to_share_with -split ","
          $projectIds = $row.project_id_to_share_with -split ","

          Write-Host "Processing Service Connection: $spn"

          # Validate project names and IDs
          if (-not $projectNames -or -not $projectIds) {
              Write-Error "Missing project names or IDs for SPN: $spn"
              continue
          }

          # Ensure project names and IDs match in length
          if ($projectNames.Length -ne $projectIds.Length) {
              Write-Error "Mismatch between project names and IDs for SPN: $spn"
              continue
          }

          # Process each project for the current SPN
          for ($i = 0; $i -lt $projectNames.Length; $i++) {
              $projectName = $projectNames[$i]
              $projectId = $projectIds[$i]

              # Escape special characters for logging
              Write-Host ("Sharing Service Connection {0} with Project {1} ({2})" -f $spn, $projectName, $projectId)

              # Call Share-ServiceConnection.ps1
              try {
                  ./Share-ServiceConnection.ps1 -PatToken $(patToken) `
                                                 -AzOrgURL "https://dev.azure.com/your-org" `
                                                 -AzProject "Sandpit.DevTest" `
                                                 -AzSCName $spn `
                                                 -ProjectNameToShareWith $projectName `
                                                 -ProjectIdToShareWith $projectId
                  Write-Host "Successfully shared service connection $spn with Project $projectName"
              } catch {
                  Write-Error ("Failed to share service connection {0} with Project {1}. Error: {2}" -f $spn, $projectName, $_.Exception.Message)
              }
          }
      }
    azurePowerShellVersion: LatestVersion


















































param (
    [Parameter(Mandatory=$true)]
    [string]$PatToken, # Personal Access Token for Azure DevOps authentication

    [Parameter(Mandatory=$true)]
    [string]$AzOrgURL, # Organization URL (e.g., https://dev.azure.com/your-org/)

    [Parameter(Mandatory=$true)]
    [string]$AzProject, # Source project name where the service connection exists

    [Parameter(Mandatory=$true)]
    [string]$AzSCName, # Name of the service connection to be shared

    [Parameter(Mandatory=$true)]
    [string]$ProjectNameToShareWith, # Target project name

    [Parameter(Mandatory=$true)]
    [string]$ProjectIdToShareWith # Target project ID
)

# Encode PAT for Authorization Header
$base64AuthInfo = [Convert]::ToBase64String([Text.Encoding]::ASCII.GetBytes(":$PatToken"))

# GET ServiceConnection ID
$serviceConnectionEndpoint = "$AzOrgURL/$AzProject/_apis/serviceendpoint/endpoints?endpointNames=$AzSCName&api-version=7.1"
try {
    $OutputSC = Invoke-RestMethod -Uri $serviceConnectionEndpoint -Method GET -Headers @{
        Authorization=("Basic {0}" -f $base64AuthInfo)
    } -ErrorAction Stop
} catch {
    Write-Error "Failure getting service connection ID: $($_.Exception.Message)"
    return
}

# Validate and Extract Service Connection ID
if ($OutputSC.value -and $OutputSC.value.Count -gt 0) {
    $serviceConnectionId = $OutputSC.value[0].id
    Write-Host "Found Service Connection ID: $serviceConnectionId"
} else {
    Write-Error "No service connection found with name: $AzSCName"
    return
}

# Prepare Service Connection Share URL
$serviceConnectionShareUrl = "$AzOrgURL/_apis/serviceendpoint/endpoints/$serviceConnectionId/share?api-version=7.1-preview.1"

# Create JSON Body for Sharing Service Connection
$jsonBody = @{
    projectReference = @{
        id = $ProjectIdToShareWith
        name = $ProjectNameToShareWith
    }
} | ConvertTo-Json -Depth 3 -Compress

# Debug: Log JSON Body
Write-Host "DEBUG: Generated JSON Body for Project $ProjectNameToShareWith:"
Write-Host $jsonBody

Write-Host "Sharing service connection with project: $ProjectNameToShareWith ($ProjectIdToShareWith)"

try {
    $response = Invoke-RestMethod -Uri $serviceConnectionShareUrl -Method POST -ContentType "application/json" -Body $jsonBody -Headers @{
        Authorization=("Basic {0}" -f $base64AuthInfo)
    } -ErrorAction Stop
    Write-Host "Successfully shared service connection with project: $ProjectNameToShareWith"
} catch {
    if ($_.Exception.Message -match "already exists") {
        Write-Host "Service connection is already shared with project: $ProjectNameToShareWith"
    } else {
        Write-Error "Failed to share service connection for project $ProjectNameToShareWith."
        Write-Error "Error Details: $($_.Exception | ConvertTo-Json -Depth 3)"
    }
}






































- task: AzurePowerShell@5
  displayName: 'Share Service Connection'
  inputs:
    azureSubscription: 'sandpit-01-vsts'
    ScriptType: InlineScript
    Inline: |
      # Navigate to the scripts directory
      cd /scripts

      # Run Get-TableContents.ps1 to retrieve the table data
      $output = ./Get-TableContents.ps1 -ResourceGroupName "sandpit-01-rg-dev-01" `
                                         -StorageAccountName "sandpitsa" `
                                         -TableName "demo" `
                                         -TableOnly $true

      # Validate if $output has data
      if (-not $output) {
          Write-Error "No data retrieved from Get-TableContents.ps1. Ensure the table exists and has valid data."
          exit 1
      }

      # Debug: Log the structure of $output
      Write-Host "DEBUG: Output from Get-TableContents.ps1:"
      Write-Host ($output | ConvertTo-Json -Depth 3)

      # Iterate through each row in the output
      foreach ($row in $output) {
          # Extract SPN, Project Names, and Project IDs
          $spn = $row.spn
          $projectNames = $row.project_name_to_share_with -split ","
          $projectIds = $row.project_id_to_share_with -split ","

          Write-Host "Processing Service Connection: $spn"

          # Ensure project names and IDs match in length
          if ($projectNames.Length -ne $projectIds.Length) {
              Write-Error "Mismatch between project names and IDs for SPN: $spn"
              continue
          }

          # Process each project for the current SPN
          for ($i = 0; $i -lt $projectNames.Length; $i++) {
              $projectName = $projectNames[$i]
              $projectId = $projectIds[$i]

              # Escape special characters for logging
              Write-Host ("Sharing Service Connection {0} with Project {1} ({2})" -f $spn, $projectName, $projectId)

              # Call Share-ServiceConnection.ps1
              ./Share-ServiceConnection.ps1 -PatToken $(patToken) `
                                             -AzOrgURL "https://dev.azure.com/your-org" `
                                             -AzProject "Sandpit.DevTest" `
                                             -AzSCName $spn `
                                             -ProjectNameToShareWith $projectName `
                                             -ProjectIdToShareWith $projectId
          }
      }
    azurePowerShellVersion: LatestVersion


#################################################




















- task: AzurePowerShell@5
  displayName: 'Share Service Connection'
  inputs:
    azureSubscription: 'sandpit-01-vsts'
    ScriptType: InlineScript
    Inline: |
      # Navigate to the scripts directory
      cd /scripts

      # Run Get-TableContents.ps1 to retrieve the table data
      $output = ./Get-TableContents.ps1 -ResourceGroupName "sandpit-01-rg-dev-01" `
                                         -StorageAccountName "sandpitsa" `
                                         -TableName "demo" `
                                         -TableOnly $true

      # Validate if $output has data
      if (-not $output) {
          Write-Error "No data retrieved from Get-TableContents.ps1. Ensure the table exists and has valid data."
          exit 1
      }

      # Process each row in the output
      $output | ForEach-Object {
          # Extract SPN, Project Names, and Project IDs
          $spn = $_.spn
          $projectNames = $_.project_name_to_share_with -split ","
          $projectIds = $_.project_id_to_share_with -split ","

          Write-Host "Processing Service Connection: $spn"

          # Iterate over projects and share the service connection for each project
          for ($i = 0; $i -lt $projectNames.Length; $i++) {
              $projectName = $projectNames[$i]
              $projectId = $projectIds[$i]

              Write-Host "Sharing Service Connection $spn with Project $projectName ($projectId)"

              # Call Share-ServiceConnection.ps1
              ./Share-ServiceConnection.ps1 -PatToken $(patToken) `
                                             -AzOrgURL "https://dev.azure.com/your-org" `
                                             -AzProject "Sandpit.DevTest" `
                                             -AzSCName $spn `
                                             -ProjectNameToShareWith $projectName `
                                             -ProjectIdToShareWith $projectId
          }
      }
    azurePowerShellVersion: LatestVersion


























- task: AzurePowerShell@5
  displayName: 'Share Service Connection'
  inputs:
    azureSubscription: 'sandpit-01-vsts'
    ScriptType: InlineScript
    Inline: |
      # Navigate to the scripts directory
      cd /scripts

      # Run Get-TableContents.ps1 to retrieve the table data
      $output = ./Get-TableContents.ps1 -ResourceGroupName "sandpit-01-rg-dev-01" `
                                         -StorageAccountName "sandpitsa" `
                                         -TableName "demo" `
                                         -TableOnly $true

      # Process each row in the output
      $output | ForEach-Object {
          # Extract SPN, Project Names, and Project IDs
          $spn = $_.spn
          $projectNames = $_.project_name_to_share_with -split ","
          $projectIds = $_.project_id_to_share_with -split ","

          Write-Host "Processing Service Connection: $spn"

          # Iterate over projects and share the service connection for each project
          for ($i = 0; $i -lt $projectNames.Length; $i++) {
              $projectName = $projectNames[$i]
              $projectId = $projectIds[$i]

              Write-Host "Sharing Service Connection $spn with Project $projectName ($projectId)"

              # Call Share-ServiceConnection.ps1
              ./Share-ServiceConnection.ps1 -PatToken $(patToken) `
                                             -AzOrgURL "https://dev.azure.com/your-org" `
                                             -AzProject "Sandpit.DevTest" `
                                             -AzSCName $spn `
                                             -ProjectNameToShareWith $projectName `
                                             -ProjectIdToShareWith $projectId
          }
      }
    azurePowerShellVersion: LatestVersion















#########################################

param (
    [Parameter(Mandatory=$true)]
    [string]$PatToken, # Personal Access Token for Azure DevOps authentication

    [Parameter(Mandatory=$true)]
    [string]$AzOrgURL, # Organization URL (e.g., https://dev.azure.com/your-org/)

    [Parameter(Mandatory=$true)]
    [string]$AzProject, # Source project name where the service connection exists

    [Parameter(Mandatory=$true)]
    [string]$AzSCName, # Name of the service connection to be shared

    [Parameter(Mandatory=$true)]
    [string]$ProjectNameToShareWith, # Target project name

    [Parameter(Mandatory=$true)]
    [string]$ProjectIdToShareWith # Target project ID
)

# Encode PAT for Authorization Header
$base64AuthInfo = [Convert]::ToBase64String([Text.Encoding]::ASCII.GetBytes(":$PatToken"))

# GET ServiceConnection ID
$serviceConnectionEndpoint = "$AzOrgURL/$AzProject/_apis/serviceendpoint/endpoints?endpointNames=$AzSCName&api-version=7.1"
try {
    $OutputSC = Invoke-RestMethod -Uri $serviceConnectionEndpoint -Method GET -Headers @{
        Authorization=("Basic {0}" -f $base64AuthInfo)
    }
} catch {
    Write-Error "Failure getting service connection ID: $($_.Exception.Message)"
    return
}

# Validate and Extract Service Connection ID
if ($OutputSC.value -and $OutputSC.value.Count -gt 0) {
    $serviceConnectionId = $OutputSC.value[0].id
    Write-Host "Found Service Connection ID: $serviceConnectionId"
} else {
    Write-Error "No service connection found with name: $AzSCName"
    return
}

# Prepare Service Connection Share URL
$serviceConnectionShareUrl = "$AzOrgURL/_apis/serviceendpoint/endpoints/$serviceConnectionId/share?api-version=7.1-preview.1"

# Create JSON Body for Sharing Service Connection
$jsonBody = @(
    @{
        id = $ProjectIdToShareWith
        name = $ProjectNameToShareWith
    }
) | ConvertTo-Json -Depth 3 -Compress

# Debug: Log JSON Body
Write-Host "DEBUG: Generated JSON Body for Project $ProjectNameToShareWith:"
Write-Host $jsonBody

Write-Host "Sharing service connection with project: $ProjectNameToShareWith ($ProjectIdToShareWith)"

try {
    $response = Invoke-RestMethod -Uri $serviceConnectionShareUrl -Method POST -ContentType "application/json" -Body $jsonBody -Headers @{
        Authorization=("Basic {0}" -f $base64AuthInfo)
    }
    Write-Host "Successfully shared service connection with project: $ProjectNameToShareWith"
} catch {
    if ($_.Exception.Message -match "already exists") {
        Write-Host "Service connection is already shared with project: $ProjectNameToShareWith"
    } else {
        Write-Error "Failed to share service connection for project $ProjectNameToShareWith: $($_.Exception.Message)"
    }
}












############################################################
###############################task: AzurePowerShell@5
displayName: 'Share Service Connection'
inputs:
  azureSubscription: 'sandpit-01-vsts'
  ScriptType: InlineScript
  Inline: |
    # Navigate to the scripts directory
    cd /scripts

    # Run Get-TableContents.ps1 to retrieve the data table
    $output = ./Get-TableContents.ps1 -ResourceGroupName "sandpit-01-rg-dev-01" `
                                       -StorageAccountName "sandpitsa" `
                                       -TableName "demo" `
                                       -TableOnly $true

    # Process each record from the data table
    $output | ForEach-Object {
        # Extract information for each record
        $spn = $_.spn
        $projectNames = $_.project_name_to_share_with -split ","
        $projectIds = $_.project_id_to_share_with -split ","

        # Log the current SPN being processed
        Write-Output "Processing SPN: $spn"

        # Share service connection for each project
        for ($i = 0; $i -lt $projectNames.Length; $i++) {
            $projectName = $projectNames[$i]
            $projectId = $projectIds[$i]

            Write-Output "Sharing SPN $spn with project $projectName ($projectId)"
            
            ./Share-ServiceConnection.ps1 -PatToken $(patToken) `
                                           -AzProject "Sandpit,DevTest" `
                                           -AzSCName $spn `
                                           -ProjectNameToShareWith $projectName `
                                           -ProjectIdToShareWith $projectId
        }
    }
  azurePowerShellVersion: LatestVersion


param (
    [Parameter(Mandatory=$true)]
    [string]$PatToken, # Personal Access Token for authentication

    [Parameter(Mandatory=$true)]
    [string]$AzProject, # Project where the connection exists

    [Parameter(Mandatory=$true)]
    [string]$AzSCName, # Name of the service connection to be shared

    [Parameter(Mandatory=$true)]
    [string]$ProjectNameToShareWith, # Target project name

    [Parameter(Mandatory=$true)]
    [string]$ProjectIdToShareWith # Target project ID
)

# Function to configure authentication headers
function Get-AuthHeader {
    return @{
        "Authorization" = "Bearer $PatToken"
        "Content-Type" = "application/json"
    }
}

# Log the input parameters
Write-Output "Starting to share service connection: $AzSCName"
Write-Output "From project: $AzProject"
Write-Output "To project: $ProjectNameToShareWith ($ProjectIdToShareWith)"

# Base URL for Azure DevOps REST API
$AzureDevOpsUrl = "https://dev.azure.com/{YourOrganization}/_apis"

# Step 1: Get the service connection ID in the source project
$serviceConnectionUrl = "$AzureDevOpsUrl/projects/$AzProject/serviceendpoint"
$response = Invoke-RestMethod -Uri $serviceConnectionUrl -Headers (Get-AuthHeader) -Method Get

$serviceConnectionId = ($response.value | Where-Object { $_.name -eq $AzSCName }).id

if (-not $serviceConnectionId) {
    Write-Error "Service connection $AzSCName not found in project $AzProject"
    exit 1
}

Write-Output "Found service connection ID: $serviceConnectionId"

# Step 2: Share the service connection with the target project
$shareUrl = "$AzureDevOpsUrl/projects/$AzProject/serviceendpoint/$serviceConnectionId/share"
$shareBody = @{
    targetProjects = @(
        @{
            id = $ProjectIdToShareWith
            name = $ProjectNameToShareWith
        }
    )
} | ConvertTo-Json -Depth 10

$response = Invoke-RestMethod -Uri $shareUrl -Headers (Get-AuthHeader) -Method Post -Body $shareBody

if ($response -ne $null -and $response.status -eq "Success") {
    Write-Output "Successfully shared service connection $AzSCName with project $ProjectNameToShareWith ($ProjectIdToShareWith)"
} else {
    Write-Error "Failed to share service connection $AzSCName with project $ProjectNameToShareWith ($ProjectIdToShareWith)"
    Write-Error "Response: $response"
    exit 1
}


















$jsonBody = @{
    projectReference = @{
        id = $projectId
        name = $projectName
    }
    name = "${AzSCName}-Managed"
} | ConvertTo-Json -Depth 2 -Compress



# Iterate over project names and IDs
for ($i = 0; $i -lt $Projectnamestosharewith.Length; $i++) {
    $projectName = $Projectnamestosharewith[$i]
    $projectId = $projectidstosharewith[$i]

    # Create JSON body dynamically
    $jsonBody = @{
        projectReference = @{
            id = $projectId
            name = $projectName
        }
        name = "$AzSCName-Managed"
    } | ConvertTo-Json -Depth 2 -Compress

    # Debug: Output JSON Body
    Write-Host "DEBUG: Generated JSON Body for Project $projectName:"
    Write-Host $jsonBody

    Write-Host "Sharing service connection with project: $projectName"

    try {
        Invoke-RestMethod -Uri $azureDevOpsServiceConnectionShareUrl -Method PATCH -ContentType "application/json" -Body $jsonBody -Headers @{
            Authorization=("Basic {0}" -f $base64AuthInfo)
        }
        Write-Host "Successfully shared service connection with project: $projectName"
    }
    catch {
        if ($_.Exception.Message -match "already exists") {
            Write-Host "Service connection share configuration already exists for project $projectName"
        } else {
            Write-Error "Failure sharing service connection for project $projectName: $($_.Exception.Message)"
        }
    }
}
































# Iterate over project names and IDs
for ($i = 0; $i -lt $Projectnamestosharewith.Length; $i++) {
    $projectName = $Projectnamestosharewith[$i]
    $projectId = $projectidstosharewith[$i]

    # Create JSON body dynamically
    $jsonBody = @{
        projectReference = @{
            id = $projectId
            name = $projectName
        }
        name = "$AzSCName-Managed"
    } | ConvertTo-Json -Depth 2 -Compress

    # Debug: Output JSON Body
    Write-Host "DEBUG: Generated JSON Body for Project $projectName:"
    Write-Host $jsonBody

    Write-Host "Sharing service connection with project: $projectName"

    try {
        Invoke-RestMethod -Uri $azureDevOpsServiceConnectionShareUrl -Method PATCH -ContentType "application/json" -Body $jsonBody -Headers @{
            Authorization=("Basic {0}" -f $base64AuthInfo)
        }
        Write-Host "Successfully shared service connection with project: $projectName"
    }
    catch {
        if ($_.Exception.Message -match "already exists") {
            Write-Host "Service connection share configuration already exists for project $projectName"
        } else {
            Write-Error "Failure sharing service connection for project $projectName: $($_.Exception.Message)"
        }
    }
}


























# Iterate over project names and IDs
for ($i = 0; $i -lt $Projectnamestosharewith.Length; $i++) {
    $projectName = $Projectnamestosharewith[$i]
    $projectId = $projectidstosharewith[$i]

    # Create JSON body dynamically
    $jsonBody = @{
        projectReference = @{
            id = $projectId
            name = $projectName
        }
        name = "$AzSCName-Managed"
    } | ConvertTo-Json -Depth 2 -Compress

    try {
        Invoke-RestMethod -Uri $azureDevOpsServiceConnectionShareUrl -Method PATCH -ContentType "application/json" -Body $jsonBody -Headers @{
            Authorization=("Basic {0}" -f $base64AuthInfo)
        }
    }
    catch {
        if ($Error[0] -match "already exists") {
            Write-Host "Service connection share configuration already exists for project $projectName"
        } else {
            Write-Error "Failure sharing service connection for project $projectName" $Error[0]
        }
    }
}



# Encode the PAT for authorization
$base64AuthInfo = [Convert]::ToBase64String([Text.Encoding]::ASCII.GetBytes(":$PatToken"))

# GET Service Connection ID
$azureDevOpsServiceConnectionIdCheck = "$AzOrgURL/$AzProject/_apis/serviceendpoint/endpoints?endpointNames=$AzSCName&api-version=7.1-preview.1"
try {
    $outputSC = Invoke-RestMethod -Uri $azureDevOpsServiceConnectionIdCheck -Method GET -ContentType "application/json" -Headers @{Authorization = "Basic $base64AuthInfo"}
} catch {
    Write-Error "Failure getting service connection ID: $_"
    return
}

# Loop through each project to share the service connection
foreach ($AzSharewithProjectName in $AzSharewithProjectNames) {
    # GET Target Project ID
    $azureDevOpsProjectIDUrl = "$AzOrgURL/_apis/projects?api-version=7.1"
    try {
        $outputProjData = Invoke-RestMethod -Uri $azureDevOpsProjectIDUrl -Method GET -ContentType "application/json" -Headers @{Authorization = "Basic $base64AuthInfo"}
        $outputProjID = ($outputProjData.value | Where-Object { $_.name -eq $AzSharewithProjectName }).id
    } catch {
        Write-Error "Failure getting project ID for project '$AzSharewithProjectName': $_"
        continue
    }

    # Share Service Connection
    $azureDevOpsServiceConnectionShareUrl = "$AzOrgURL/_apis/serviceendpoint/endpoints/$($outputSC.value[0].id)?api-version=7.1"
    $jsonBody = @{
        projectReference = @{
            id   = $outputProjID
            name = $AzSharewithProjectName
        }
        name = "$AzSCName-Managed"
    } | ConvertTo-Json -Depth 2

    try {
        Invoke-RestMethod -Uri $azureDevOpsServiceConnectionShareUrl -Method PATCH -ContentType "application/json" -Body $jsonBody -Headers @{Authorization = "Basic $base64AuthInfo"}
        Write-Host "Service connection shared successfully with project '$AzSharewithProjectName'"
    } catch {
        if ($_ -match "already exists") {
            Write-Host "Service connection share configuration already exists for project '$AzSharewithProjectName'"
        } else {
            Write-Error "Failure sharing service connection with project '$AzSharewithProjectName': $_"
        }
    }
}


Remove-TypeData -TypeName "System.Security.AccessControl.ObjectSecurity"
Import-Module Microsoft.PowerShell.Security -Force

# Proxy Address
$proxyAddress = "http://your-proxy-address:port"  # Replace with your proxy server's address

# Proxy Credentials
$proxyUsername = "your-username"  # Replace with your username
$proxyPassword = "your-password"  # Replace with your password
$proxySecureString = ConvertTo-SecureString $proxyPassword -AsPlainText -Force
$proxyCredential = New-Object System.Management.Automation.PSCredential($proxyUsername, $proxySecureString)

# Configure PowerShell to Use the Proxy
[System.Net.WebRequest]::DefaultWebProxy = New-Object System.Net.WebProxy($proxyAddress, $true)
[System.Net.WebRequest]::DefaultWebProxy.Credentials = $proxyCredential


# Define your Azure DevOps organization and Personal Access Token
$organization = "Contoso"  # Replace with your Azure DevOps organization name
$personalAccessToken = "<YourPAT>"  # Replace with your Personal Access Token
$apiVersion = "7.1-preview.4"

# Encode organization for safe URL usage
$encodedOrganization = [System.Uri]::EscapeUriString($organization)

# Construct URL to fetch all projects
$projectsUrl = "https://dev.azure.com/$encodedOrganization/_apis/projects?api-version=$apiVersion"

# Authorization Header
$authHeader = @{
    Authorization = "Basic $([Convert]::ToBase64String([Text.Encoding]::ASCII.GetBytes(":$personalAccessToken")))"
}

# Try to Fetch All Projects
try {
    Write-Output "Fetching all projects for organization: $organization..."
    $projectsResponse = Invoke-RestMethod -Uri $projectsUrl -Method Get -Headers $authHeader

    # Check if there are any projects returned
    if ($projectsResponse.value.Count -eq 0) {
        Write-Output "No projects found in the organization."
    } else {
        Write-Output "Projects found: $($projectsResponse.value.Count)"
        
        # Loop through each project and fetch details
        foreach ($project in $projectsResponse.value) {
            $projectId = $project.id
            $projectName = $project.name

            # Construct URL to fetch project details
            $projectDetailsUrl = "https://dev.azure.com/$encodedOrganization/_apis/projects/$projectId?api-version=$apiVersion"

            try {
                # Fetch detailed project information
                $projectDetails = Invoke-RestMethod -Uri $projectDetailsUrl -Method Get -Headers $authHeader

                # Extract EIM (Project Description)
                $projectDescription = if ($projectDetails.description) {
                    $projectDetails.description
                } else {
                    "No EIM Value Available"
                }

                # Output project details
                Write-Output "Project Name: $projectName"
                Write-Output "Project ID: $projectId"
                Write-Output "EIM: $projectDescription"
                Write-Output "---------------------------"
            } catch {
                # Handle errors fetching project details
                Write-Output "Error fetching details for project: $projectName"
                Write-Output "Error: $($_.Exception.Message)"
            }
        }
    }
} catch {
    # Handle errors fetching all projects
    Write-Output "Error fetching projects: $($_.Exception.Message)"
    Write-Output "Detailed Error: $($_.Exception.InnerException)"
}





- task: PublishPipelineArtifact@1
      displayName: "Publish Terraform Plan"
      inputs:
        targetPath: $(System.DefaultWorkingDirectory)/tfplan
        artifact: tfplan

- task: DownloadPipelineArtifact@2
      displayName: "Download Terraform Plan Artifact"
      inputs:
        artifact: tfplan
        targetPath: $(System.DefaultWorkingDirectory)/tfplan




ccd ./terraform

          # Initialize Terraform with remote backend configuration
          terraform init -no-color -input=false

          # Generate the plan and save it to a file
          terraform plan -var-file="variables.tfvars" -out=tfplan

          # Optional: Output the plan in JSON format for review
          terraform show -json tfplan > tfplan.json

          # Save tfplan to a shared location for the apply step
          mkdir -p $(System.DefaultWorkingDirectory)/tfplan
          cp tfplan $(System.DefaultWorkingDirectory)/tfplan/

cd ./terraform

          # Copy the downloaded tfplan to the current directory
          cp $(System.DefaultWorkingDirectory)/tfplan/tfplan .

          # Apply the plan
          terraform apply -auto-approve tfplan




variables:
  # Build reason
  - template: dev.yaml
  - name: why
    ${{ if eq(variables['Build.Reason'], 'PullRequest') }}:
      value: pr
    ${{ elseif eq(variables['Build.Reason'], 'Manual') }}:
      value: manual
    ${{ elseif eq(variables['Build.Reason'], 'IndividualCI') }}:
      value: indivci
    ${{ elseif eq(variables['Build.Reason'], 'Schedule') }}:
      value: scheduled
    ${{ else }}:
      value: other

  - name: POOL_NAME
    value: "bla-multi-cstmg-01-aks-subscription-prod-v2"
  - name: BuildName
    value: $(Build.DefinitionName)_$(why)_$(Date:yyyyMMdd)


stages:
- stage: PublishArtifact
  displayName: Publish Artifact to Nexus
  jobs:
  - job: PackageAndUpload
    displayName: Package and Upload Artifact
    steps:
    - script: |
        zip -r $(appPackageName) . -x ".git"
      workingDirectory: $(System.DefaultWorkingDirectory)
      displayName: "Package Build"
      enabled: true

    - script: |
        curl -v --user $(nexususername):$(nexuspassword) \
             --upload-file $(appPackageName) \
             $(artifactRepo)/$(appName)/$(appPackageName)
      workingDirectory: $(System.DefaultWorkingDirectory)
      displayName: "Publish Artifact in Nexus"
      enabled: true



parameters:
- name: Region
  default: ''
- name: SourceRepositoryName
  default: ''
- name: TfvarsName
  default: ''
- name: StateName
  default: ''

trigger: none

variables:
  - group: 'IaC_General_UKS'
  - name: SourceRepositoryName
    value: ${{ parameters.SourceRepositoryName }}
    readonly: true
  - name: TfvarsName
    value: ${{ parameters.TfvarsName }}
    readonly: true
  - name: StateName
    value: ${{ parameters.StateName }}
    readonly: true




- task: PowerShell@2
  displayName: 'Terraform validate'
  inputs:
    targetType: 'inline'
    script: |
      Write-Host "##[group]Terraform validate"
      Write-Host "Checks the syntax and validity of Terraform code. It checks for errors in the code, ensuring that the configuration is correctly written."
      Write-Host "Working Directory: $(variables.CustomPath)"
      Write-Host "##[endgroup]"
      
      Write-Host "Run terraform init"
      terraform init -backend=false
      
      Write-Host "Run terraform validate"
      $validationResult = terraform validate -json | ConvertFrom-Json
      
      Write-Host "Check if errors were found"
      if ($validationResult.error_count -gt 0) {
        Write-Error "Errors were found during Terraform validation:"
        $validationResult.diagnostics | ForEach-Object { Write-Error $_.message }
        exit 1
      } else {
        Write-Host "No validation errors found. Proceeding further."
      }
    pwsh: true
    workingDirectory: '$(variables.CustomPath)'





- task: Bash@3
  displayName: 'Install pwsh if not installed'
  script: |
    if [ ! -x "$(command -v pwsh)" ]; then
      echo "Installing PowerShell..."
      sudo apt-get update
      sudo apt-get install -y powershell
    else
      echo "PowerShell is already installed. Continuing to the next step."
    fi
  retryCount: 3



# Run terraform validate
      terraform init -backend=false
      terraform validate -json > validation_result.json
    displayName: 'Run Terraform Validate'

  - script: |
      # Check if errors were found
      if [ -s validation_result.json ]; then
        echo "Errors were found during Terraform validation:"
        cat validation_result.json
        exit 1  # Fail the build
      else
        echo "No errors found. Proceeding further."
      fi
    displayName: 'Check Validation Results'


Write-Host "##[group]TFLint Information"
      Write-Host "This task checks Terraform files using TFLint to ensure best practices and coding standards are followed."
      Write-Host "Working Directory: $(WorkingDirectory)"
      Write-Host "##[endgroup]"




echo -e "\e[1;31mTerraform plan detected changes. Failing the stage.\e[0m"


- task: PowerShell@2
      displayName: Check Terraform plan changes
      inputs:
        targetType: 'inline'
        script: |
          $terraformOutput = Get-Content -Path '$(System.DefaultWorkingDirectory)/terraform-output.txt' -Raw
          if ($terraformOutput -like "*Terraform will perform*") {
            Write-Error "Terraform plan detected changes. Failing the stage."
            exit 1
          }


- powershell: |
    terraform show -json $(System.DefaultWorkingDirectory)/terraform-output.tfplan > $(System.DefaultWorkingDirectory)/terraform-output.txt
  displayName: 'Save Terraform Plan Output'

- task: PowerShell@2
  displayName: 'Check Node.js version'
  inputs:
    targetType: 'inline'
    script: |
      node --version


- task: Bash@3
  displayName: 'Check Terraform plan changes'
  inputs:
    targetType: 'inline'
    script: |
      terraformOutput=$(cat "$(System.DefaultWorkingDirectory)/terraform-output.txt")

      if [[ $terraformOutput == *"Terraform will perform"* ]]; then
        echo "Terraform plan detected changes. Failing the stage."
        exit 1
      fi


- task: Bash@3
      displayName: 'Check Terraform plan changes'
      inputs:
        targetType: 'inline'
        script: |
          terraformOutput=$(cat "$(System.DefaultWorkingDirectory)/terraform-output.txt")

          if [[ $terraformOutput == *"Terraform will perform"* ]]; then
            echo "Terraform plan detected changes. Failing the stage."
            exit 1
          ```
stages:
- stage: BashOnlyStage
  displayName: 'Bash Only Stage'
  jobs:
  - job: RunBashScript
    displayName: 'Run Bash Script'
    pool:
      vmImage: 'ubuntu-latest'
    steps:
    - task: Bash@3
      displayName: 'Run Bash Script'
      inputs:
        targetType: 'inline'
        script: |
          echo "Hello from Bash task!"
____________________________________________

terraformOutput=$(cat "$(System.DefaultWorkingDirectory)/tfplan")

          if [[ $terraformOutput == *"Terraform will perform"* ]]; then
            echo "Terraform plan detected changes. Failing the stage."
            exit 1
          else
            echo "No Terraform plan changes detected."
          fi

terraform show -no-color -json "$(Build.SourcesDirectory)/$(SourceRepositoryName)/tf.tfplan" > $(Build.ArtifactStagingDirectory)/terraform-output.txt


______________________________________________________________________________________________________

- script: |
    terraform show -no-color -json "$(Build.SourcesDirectory)/$(parameters.SourceRepositoryName)/tf.tfplan"
    terraform show -no-color -json "$(Build.SourcesDirectory)/$(parameters.SourceRepositoryName)/tf.tfplan" > $(System.DefaultWorkingDirectory)/terraform-output.txt

    # Check for changes and fail the stage if FailOnChanges is true
    if [[ $(terraform show -no-color -json "$(Build.SourcesDirectory)/$(parameters.SourceRepositoryName)/tf.tfplan") != "null" && $(parameters.FailOnChanges) == true ]]; then
        echo "Terraform plan detected changes. Failing the stage."
        exit 1
    fi
  displayName: 'Check the Terraform plan'
  workingDirectory: '$(Build.SourcesDirectory)/$(parameters.SourceRepositoryName)/env'


# Run Terraform plan and save the output to a file
terraform plan -out=tfplan

# Show the plan in text format and save it to a file
terraform show -no-color tfplan > tfplan.txt

# Check if the "No changes" message is present in the output
if ! grep -q "No changes. Your infrastructure matches the configuration." tfplan.txt; then
    echo "Terraform plan detected changes. Failing the stage."
    exit 1
else
    echo "No changes detected in the Terraform plan. Proceeding with the stage."
fi

if [[ ! $terraformOutput == *"No changes. Your infrastructure matches the configuration."* ]]; then
  echo "Terraform plan detected changes. Failing the stage."
  exit 1
fi
_______________________________________________________________________________________________________________________________________________________

trigger: none

pool:
  vmImage: "ubuntu-latest"

variables:
  - group: 'azure'
  - name: SourceRepositoryName
    value: '$(Build.SourceBranchName)'  # Use the branch name dynamically
    readOnly: true

steps:
- checkout: self
  persistCredentials: true
  clean: true
  displayName: 'Checkout Pull request source branch'

- task: Bash@3
  displayName: 'Check and install Zip'
  script: |
    if [ ! -x "$(command -v zip)" ]; then
      echo "Zip not installed"
      sudo apt-get update
      sudo apt-get install zip -y
    fi
  retryCountOnTaskFailure: 3

- task: Bash@3
  displayName: 'Install pwsh'
  script: |
    sudo apt-get update
    sudo apt-get install -y powershell
  retryCountOnTaskFailure: 3

- task: TerraformInstaller
  displayName: 'Terraform Install'
  inputs:
    terraformVersion: '1.7.1'
    terraformLocation: 'inline'

- task: PowerShell@2
  displayName: 'Terraform fmt check'
  inputs:
    targetType: 'inline'
    script: |
      $output = terraform fmt --recursive
      if (-not $output) {
        Write-Host "terraform fmt found no issues. Moving on."
      } else {
        Write-Error "terraform fmt found issues. Please run terraform fmt locally to format your code and push to your branch."
      }
  pwsh: true
  workingDirectory: '$(Build.SourcesDirectory)/$(variables.SourceRepositoryName)'

- task: PowerShell@2
  displayName: 'Terraform validate'
  inputs:
    targetType: 'inline'
    script: |
      $validateOutput = terraform validate -json
      if ($validateOutput -eq "[]") {
        Write-Host "terraform validate succeeded. Moving on."
      } else {
        Write-Error "terraform validate failed. Please check the following issues: $($validateOutput -join ', ')"
      }
  pwsh: true
  workingDirectory: '$(Build.SourcesDirectory)/$(variables.SourceRepositoryName)'


______________________________________________________________________________________________________________________________________-

trigger: none

pool:
  vmImage: "ubuntu-latest"

variables:
  - group: 'Azure'
  - name: SourceRepositoryName
    value: '$(Build.SourceBranchName)'  # Use the branch name dynamically
    readOnly: true

steps:
- checkout: self
  persistCredentials: true
  clean: true
  displayName: 'Checkout Pull request source branch'

- task: Bash@3
  displayName: 'Check and install Zip'
  script: |
    if [ ! -x "$(command -v zip)" ]; then
      echo "Zip not installed"
      sudo apt-get update
      sudo apt-get install zip -y
    fi
  retryCountOnTaskFailure: 3

- task: Bash@3
  displayName: 'Install pwsh'
  script: |
    sudo apt-get update
    sudo apt-get install -y powershell
  retryCountOnTaskFailure: 3

- task: TerraformInstaller
  displayName: 'Terraform Install'
  inputs:
    terraformVersion: '1.7.1'
    terraformLocation: 'inline'

- task: PowerShell@2
  displayName: 'Terraform fmt check'
  inputs:
    targetType: 'inline'
    script: |
      $output = terraform fmt --recursive
      if (-not $output) {
        Write-Host "terraform fmt found no issues. Continue..."
      } else {
        Write-Error "terraform fmt found issues. Please run terraform fmt locally to format your code and push to your branch."
      }
  pwsh: true
  workingDirectory: '$(Build.SourcesDirectory)/$(variables.SourceRepositoryName)'

- task: PowerShell@2
  displayName: 'TFLint Install'
  inputs:
    targetType: 'inline'
    script: |
      wget https://github.com/terraform-linters/tflint/releases/download/v0.29.0/tflint_linux_amd64.zip
      unzip tflint_linux_amd64.zip
      sudo mv tflint /usr/local/bin/
      rm tflint_linux_amd64.zip
  pwsh: true
  workingDirectory: '$(Build.SourcesDirectory)/$(variables.SourceRepositoryName)'

- task: PowerShell@2
  displayName: 'TFLint check'
  inputs:
    targetType: 'inline'
    script: |
      $tflintOutput = tflint
      if (-not $tflintOutput) {
        Write-Host "TFLint found no issues. Continue..."
      } else {
        Write-Error "TFLint found issues. Please check the following issues: $($tflintOutput -join ', ')"
      }
  pwsh: true
  workingDirectory: '$(Build.SourcesDirectory)/$(variables.SourceRepositoryName)'

